<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sen</title>
  
  
  <link href="http://senye.ink/atom.xml" rel="self"/>
  
  <link href="http://senye.ink/"/>
  <updated>2021-07-28T15:20:54.244Z</updated>
  <id>http://senye.ink/</id>
  
  <author>
    <name>zhangsen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>day28</title>
    <link href="http://senye.ink/2021/07/28/day28/"/>
    <id>http://senye.ink/2021/07/28/day28/</id>
    <published>2021-07-28T15:20:12.422Z</published>
    <updated>2021-07-28T15:20:54.244Z</updated>
    
    <content type="html"><![CDATA[<h5 id="数据库表之间的关系："><a href="#数据库表之间的关系：" class="headerlink" title="数据库表之间的关系："></a>数据库表之间的关系：</h5><p>​    一对一 一对多 多对多（虽然建立的表与表之间的关系，但是这个关系并不会被数据库维护，需要通过外键约束来通知数据库帮助我们维护表之间的关系</p><p>外键约束： </p><p>​     可以使用外键约束来同住数据库维护表与表之间数据的完整性和正确性</p><p>​     外键作用： 维护数据的完整性和正确性</p><p>​         foreign key (orders id )  references orders (id)</p><p>拓展 ：外键不推荐使用 在高吞吐的情境下，应优先保证数据入库 如果使用外键，则可能会发生数据无法正确入库的情况 造成数据丢失，所以不推荐使用外键</p><p>order by 子句</p><p>在得到查询结果之后，对查询结果跟据某一个字段进行排序输出  、</p><p>order by 关键字 永远出现在查询语句的最后面，执行顺序也是最后一个</p><p>基本语句 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select *from table_name order by column_name asc|desc&#x2F;&#x2F; 默认升序</span><br><span class="line">select chinese from exam order by chinese; </span><br><span class="line">select chinese+ifnull(math,0)+english as sum from exam order by chinese+ifnull(math,0)+english desc; &#x2F;&#x2F;降序</span><br><span class="line">select name,chinese+english+ifnull(math,0) as sum from exam where name like &#39;张%&#39; order by sun;&#x2F;&#x2F;对姓张的同学进行排序输出</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>聚集函数 count</p><p>对于表中所有满足条件的行进行技术操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">基本语句 （遇到列中有行的值为null的不计数）</span><br><span class="line">select count(column_name)from table_name; </span><br><span class="line">统计班级里有多少学生</span><br><span class="line">select count(*) from exam;&#x2F;&#x2F;count(1)和count(*)在大量数据面前 效率相当</span><br><span class="line">select count(math) from exam where math&gt;90;&#x2F;&#x2F;统计数学大于90</span><br><span class="line">select count(chinese+ifnull(math)+english) from exam where chinese+ifnull(math)+english &gt;250;&#x2F;&#x2F;统计总分大于250</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>聚集函数  sum</p><p>对于满足条件的行将指定字段全部数据求和</p><p>基本 语句sum只能求数值之和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select sum(column_name) from table_name;</span><br><span class="line">select sum(math) from exam; &#x2F;&#x2F;统计数学总成绩</span><br><span class="line">select sum(math),sum(chinese),sum(english) from exam;&#x2F;&#x2F;统计各科总成绩</span><br><span class="line">select sum(ifnull(math)+chinese+english) from exam;&#x2F;&#x2F;统计总成绩</span><br></pre></td></tr></table></figure><p>聚集函数 AVG</p><p>对于满足条件的行，将指定的字段数据全部求平均值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select avg(column_name) from table_name;</span><br><span class="line">select avg(math) from exam; &#x2F;&#x2F;求数学平均分</span><br><span class="line">select avg(chinese+ifnull(math,0)+english) from exam;&#x2F;&#x2F;班级总分平均分</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>聚集函数 max、min</p><p>对满足条件的行，在指定字段内查找最大值和最小值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select max(column_name)|min(column_name) from table_name</span><br><span class="line">select max(ifnull(math,0)+chinese+english),min(ifnull(math,0)+chinese+english) from exam &#x2F;&#x2F;求班级最高和最低</span><br><span class="line">子查询操作</span><br><span class="line">select name,chinese from exam where chinese in (select max(chinese) from exam); &#x2F;&#x2F;查询语文成绩最高的学生他的语文分数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跟组操作  group by</p><p>根据指定字段名进行分组，字段相同的分在同一组，同一组只能显示本组的第一条数据\</p><p>分组之后只会展示同一组的第一条数据但没有覆盖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select column_name1,column_name2 from table_name group by column_name;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>数据库的备份与恢复</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&gt; mysqldump -urooy -p123456 mydb1&gt;D:&#x2F;1.sql</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>JDBC实现步骤</p><ol><li>注册数据库驱动</li><li>获取数据库连接</li><li>创建传输器</li><li>传输sql语句 并且返回结果</li><li>遍历结果</li><li>关闭资源</li></ol><p>代码实现</p><p>JDBC工具类</p><p>在jdbc实现过程中，注册驱动获取数据库连接以及关闭资源代码都在重复，可以这重复的代码放到一个方法中，这个方法可以定义在工具类中</p><p>JDBCUtils.java   工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.jdbc.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="comment">//私有化构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JDBCUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建properties类对象</span></span><br><span class="line">    <span class="comment">//静态属性（对象）---全局统一--只需要创建一次对象就可以读取配置内容</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span>  Properties p =<span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块 保证先读取配置文件的内容</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//JDBCUtils.class---获取当前类的字节码对象</span></span><br><span class="line">        <span class="comment">//getClassloader（）----获取类加载器</span></span><br><span class="line">        <span class="comment">//getResource（“src目录下的文件名称”）---获取当前工程的src</span></span><br><span class="line">        <span class="comment">//getPath()----把url类型转换成String类型</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(JDBCUtils.class.getClassLoader().getResource(<span class="string">&quot;conf.properties&quot;</span>).getPath())));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义静态方法----注册驱动以及获取数据库连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//注册数据库驱动</span></span><br><span class="line">        Class.forName(p.getProperty(<span class="string">&quot;driver&quot;</span>));</span><br><span class="line">        <span class="comment">//获取数据库连接</span></span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(p.getProperty(<span class="string">&quot;url&quot;</span>),p.getProperty(<span class="string">&quot;user&quot;</span>) ,p.getProperty(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态方法 关闭资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Connection conn, Statement stat, ResultSet rs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rs != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                rs = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stat != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                stat.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                stat = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                conn = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过工具类去调用静态方法注册数据库驱动 返回数据库连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">//创建传输器</span></span><br><span class="line">            stat = conn.createStatement();</span><br><span class="line">            <span class="comment">//传输sql语句并且返回结果</span></span><br><span class="line">            <span class="keyword">int</span> i = stat.executeUpdate(<span class="string">&quot;delete from exam  where id=6&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功受影响行数：&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            JDBCUtils.close(conn, stat, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新数据</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stat = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用工具类里的静态方法来注册驱动并返回数据库连接</span></span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            stat = conn.createStatement();</span><br><span class="line">            <span class="keyword">int</span> i = stat.executeUpdate(<span class="string">&quot;update exam set name=&#x27;刘备&#x27;where id=4&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">            throwables.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(conn, stat, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>conf.prorerties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb1</span><br><span class="line">user&#x3D;root</span><br><span class="line">password&#x3D;123456</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.注册数据库驱动</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.获取数据库连接</span></span><br><span class="line">      Connection conn = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/mydb1?user=root&amp;password=123456&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.创建传输器</span></span><br><span class="line">      Statement stat = conn.createStatement();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//4.传输sql语句并返回结果</span></span><br><span class="line">      ResultSet rs = stat.executeQuery(<span class="string">&quot;select * from exam&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5.遍历结果</span></span><br><span class="line">      <span class="keyword">while</span> (rs.next()) &#123;<span class="comment">//挪动下一行 如果下一行有数据</span></span><br><span class="line">          <span class="comment">//获取一列每行的数据</span></span><br><span class="line">          <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;id:&quot;</span> + id);</span><br><span class="line">          String name = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//关闭资源（后创建的先关闭）</span></span><br><span class="line">      rs.close();</span><br><span class="line">      stat.close();</span><br><span class="line">      conn.close();</span><br></pre></td></tr></table></figure><p>数据库连接的基本操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;数据库表之间的关系：&quot;&gt;&lt;a href=&quot;#数据库表之间的关系：&quot; class=&quot;headerlink&quot; title=&quot;数据库表之间的关系：&quot;&gt;&lt;/a&gt;数据库表之间的关系：&lt;/h5&gt;&lt;p&gt;​    一对一 一对多 多对多（虽然建立的表与表之间的关系，但是这个关系并</summary>
      
    
    
    
    
    <category term="数据库 JDBC" scheme="http://senye.ink/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-JDBC/"/>
    
  </entry>
  
  <entry>
    <title>day27</title>
    <link href="http://senye.ink/2021/07/27/day27/"/>
    <id>http://senye.ink/2021/07/27/day27/</id>
    <published>2021-07-27T13:22:48.941Z</published>
    <updated>2021-07-27T13:23:58.563Z</updated>
    
    <content type="html"><![CDATA[<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>   保证类产生单个实例对象</p><p>   饿汉式：优点是没有线程安全问题，缺点是无论是否需要对象都会创建</p><p>  懒汉式：优点是需要创建对象时才创建，缺点是线程不安全</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ol><li><p>mysql 数据库使用</p><p> a.登录数据库、</p><p>cmd窗口中输入：mysql -uroot -p123456   账号和密码 回车</p><p>b.退出数据库</p><p>快捷点：ctrl+c</p><p>指令：exit； quit；</p></li><li><p>MySQL数据库服务器，数据库和表的关系<br>  所谓安装数据库服务器，只是在机器上咋黄了一个数据库管理程序，这个管理程序可以管理多个数据库，一般开人员会针对每一个应用创建一个数据库。<br>  为保存应用中的实体数据，一般会在数据库中创建多个表，以保存程序中实体的数据。</p></li><li><p>SQL语言<br>  Structured Query language 结构化查询语言<br>  非过程性语言<br>  美国国家标准局（ANSI）与国际标准化组织（ISO）已经制定了SQL标准<br>  为加强SQL的语言能力，各厂商增强了过程性语言的特征</p><pre><code>  如Oracle的PL、SQL过程性的处理能力  SQL Server Sybase的T—SQL</code></pre><p>  SQL是用来存取关系数据库的语言，具有查询，操纵，定义和控制关系型数据库的四方面功能</p></li></ol><p>查看当前数据库的字符接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like %character%;</span><br></pre></td></tr></table></figure><p>1.1 创建数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database mydb1;&#x2F;&#x2F;创建数据库</span><br><span class="line">create database mydb2 set character utf8;创建数据库并且使用utf-8字符集</span><br><span class="line">create database mydb3 chacacter set utf8 collate utf8_bin ;创建utf-8字符集 并校对规则的数据库</span><br></pre></td></tr></table></figure><p>​       </p><p>1.2查看所有的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>1.3 查看数据库创建语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create datdabase mydb2;</span><br></pre></td></tr></table></figure><p>1.4删除数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database mydb3;</span><br></pre></td></tr></table></figure><p>1.5修改数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database mydb1</span><br></pre></td></tr></table></figure><p>1.6选择数据库</p><p>​      必须先选择数据库再去操作表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mydb1;</span><br></pre></td></tr></table></figure><p>1.7查看当前选择的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select database();</span><br></pre></td></tr></table></figure><p>2.1 创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table user ( id int, name char(10),password char(20),birthday date ); </span><br><span class="line">create table table_name(</span><br><span class="line">field1 datatype,</span><br><span class="line">field2 datatype,</span><br><span class="line">field3 datatype</span><br><span class="line">);[character set 字符集] [collate] 校对规则、</span><br><span class="line">field：指定类名   datatype：指定类类型</span><br></pre></td></tr></table></figure><p>常用的数据类型：</p><p>​     字符串型 varchar char 0-255</p><p>​    char（20）  占据存储的空间一定。由于存储的数据长度是一定的，在读取数据时，也会读取固定的长度，无需判断数据的长度，所以读取速度最快</p><p>   varchar（20） 占据存储空间是变化的，存储数据的长度是变化的，所以需要先判断数据的长度，再去读取，相对char来说，varchar读取的效率稍低</p><p>如果有限考虑读取速度的话，可以将字段设置为char类型，如果有限考虑存储空间，可以将字段设置为varchar类型</p><p>大数据类型： blob text</p><p>数值型：tinyint smallint int bigint float double</p><p>逻辑型：bit 1/0</p><p>日期型：date time datetime timestamp</p><p>例 创建一个员工表employee</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create table employee(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(22),</span><br><span class="line">gender varchar(20),</span><br><span class="line">birthday daye,</span><br><span class="line">entry_data date,</span><br><span class="line">job varchar(20),</span><br><span class="line">salary double,</span><br><span class="line">resume text</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>查看表的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">desc employee;  desc tabname;</span><br></pre></td></tr></table></figure><p>2.2查看当前数据库中有哪些表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">show tables;  查看数据库表建表的语句： show create table tabname;</span><br><span class="line">alter table table_name add column_name datatype [default expr] [,column datatype]...;  对表的语句进行了追加</span><br><span class="line">alter table table modify column_name datatype[default expr][,column datatype]..;</span><br><span class="line">对表的语句进行了修改</span><br><span class="line">alter table table drop column; 删除表</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>修改表的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table 表名 to 表名</span><br></pre></td></tr></table></figure><p>修改列的名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name change old_column new_column typefiled;</span><br></pre></td></tr></table></figure><h4 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h4><ol><li><p>数据库表记录crud语句</p><p>insert语句  增加数据</p><p>update语句  更新数据</p><p>delete语句  删除数据</p><p>select语句 查找数据</p><p>insert语句</p></li><li><p>使用insert语句向表中插入数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into table_name[(column [,column...])] values (value[,value...]);</span><br></pre></td></tr></table></figure><p>a .插入的数据应与字段的数据类型相同</p><p>b.数据的大小应在列的规定范围内，例如不能将一个长度为80的字符串加入到长度为40的列中</p><p>c.在values中列出的数据位置必须与被加入的列的排列位置相对应</p><p>d.字符个日期数据应包含在单引号中</p><p>e.插入空值 不指定或insert into table value（null）</p><p>f.如果要插入所有的字段可以省写列列表，直接按表中字段顺序写值列表</p></li></ol><p>• mysql有六处使用了字符集，分别为：client 、connection、database、results、server 、system。</p><p> • client是客户端使用的字符集。</p><p> • connection是连接数据库的字符集设置类型，如果程序没有指明连接数据库使用的字符集类型就按照服务器端默认的字符集设置。</p><p> • database是数据库服务器中某个库使用的字符集设定，如果建库时没有指明，将使用服务器安装时指定的字符集设置。</p><p> • results是数据库给客户端返回时使用的字符集设定，如果没有指明，使用服务器默认的字符集。</p><p> • server是服务器安装时指定的默认字符集设定。 show variables like’character%’; set names gbk;临时修改当前CMD窗口和mysql的通信编码字符集</p><p> • system是数据库系统使用的字符集设定。（utf-8不可修改） 请到mysql安装目录下面找到 my.ini文件 修改default-character-set=utf8 为 default-character-set=gbk 有两个地方都要改 修改文件前，先停止mysql服务 ，等修改后再重新启动 使用dos命令 ：net stop mysql 来停止服务 net start mysql 来启动</p><p>如果不使用where子句，将删除表中所有数据。</p><p> • update table_name set 字段名=’’; • Delete语句不能删除某一列的值（可使用update） </p><p>• drop table table_name; • 使用delete语句仅删除记录，不删除表本身。如要删除表，使用drop table语句。 外键约束 </p><p>• 同insert和update一样，从一个表中删除记录将引起其它表的参照完整性问题，在修改数据库数据时，头脑中应该始终不要忘记这个潜在的问题。</p><p> • 删除表中数据也可使用TRUNCATE TABLE 语句，它和delete有所不同，参看mysql文档。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;单例设计模式&quot;&gt;&lt;a href=&quot;#单例设计模式&quot; class=&quot;headerlink&quot; title=&quot;单例设计模式&quot;&gt;&lt;/a&gt;单例设计模式&lt;/h3&gt;&lt;p&gt;   保证类产生单个实例对象&lt;/p&gt;
&lt;p&gt;   饿汉式：优点是没有线程安全问题，缺点是无论是否需要对象都会</summary>
      
    
    
    
    
    <category term="单例设计模式 数据库" scheme="http://senye.ink/tags/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>day25</title>
    <link href="http://senye.ink/2021/07/26/day25/"/>
    <id>http://senye.ink/2021/07/26/day25/</id>
    <published>2021-07-26T13:36:17.170Z</published>
    <updated>2021-07-26T13:40:03.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>   <strong>优先级（当作权重来尽量避免死锁的发生）</strong></p><p>​        优先级1-10，优先级越大的线程对象理论上抢占到资源的概率越大</p><p>​        如果优先级差值大于5 理论上抢占资源的概率会稍大一些、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建线程对象</span></span><br><span class="line"> Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> PDemo(),<span class="string">&quot;A&quot;</span>);</span><br><span class="line"> Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> PDemo(),<span class="string">&quot;B&quot;</span>);</span><br><span class="line"> <span class="comment">//设置优先级</span></span><br><span class="line"> t1.setPriority(<span class="number">1</span>);</span><br><span class="line"> t2.setPriority(<span class="number">10</span>);</span><br><span class="line"> <span class="comment">//开启线程</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代表线程任务信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;i++)&#123;</span><br><span class="line"> System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line"> <span class="comment">//休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  <strong>守护线程</strong></p><p>​        如果被守护线程结束，随之守护线程也结束</p><p>​        如果不是手动设置成的守护线程就是被守护线程</p><p>​        被守护线程可以有多个，每个被守护线程结束所有守护线程才结束</p><p>​        内存里有最大的守护线程—GC</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeamonDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建线程对象</span></span><br><span class="line"> Thread t1=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Soilder(),<span class="string">&quot;超级兵&quot;</span>);</span><br><span class="line"> Thread t2=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Soilder(),<span class="string">&quot;宫本&quot;</span>);</span><br><span class="line"> Thread t3=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Soilder(),<span class="string">&quot;炮车&quot;</span>);</span><br><span class="line"> Thread t4=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Soilder(),<span class="string">&quot;花木兰&quot;</span>);</span><br><span class="line"> <span class="comment">//设置守护线程</span></span><br><span class="line"> t1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> t2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> t3.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> t4.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"> <span class="comment">//开启线程</span></span><br><span class="line"> t1.start();</span><br><span class="line"> t2.start();</span><br><span class="line"> t3.start();</span><br><span class="line"> t4.start();</span><br><span class="line"> <span class="comment">//主线程---BOSS(被守护线程)</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">10</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;BOOS掉了一滴血还剩&quot;</span> + i + <span class="string">&quot;滴血。。。&quot;</span>);</span><br><span class="line"> <span class="comment">//休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">5</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类代表小兵</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soilder</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"> <span class="comment">//描述小兵掉血过程</span></span><br><span class="line"> System.out.println(Thread.currentThread().getName() + <span class="string">&quot;掉了一滴血还剩&quot;</span> + i + <span class="string">&quot;滴血。。。&quot;</span>);</span><br><span class="line"> <span class="comment">//休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="网络编程（套接字）"><a href="#网络编程（套接字）" class="headerlink" title="网络编程（套接字）"></a>网络编程（套接字）</h3><p>​        根据网络来进行数据传输</p><p>  物理层、数据链路层、网络层、传输层（协议UDP,TCP）、会话层、表示层、应用层 </p><p>  ip地址—确定网络中主机位置   IPv4 由四位0-255的数字组合而成</p><p> 域名 —-不会重复，可以映射成对应的ip</p><p> 端口：计算机和外界进行数据交互的媒介  端口号（0——65535） 0-1024之间的端口基本已经被系统提前占用，推荐只用1024后面的端口号</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.net.address;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetSocketAddressDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建对象---指定IP地址和端口号</span></span><br><span class="line"> <span class="comment">//localhost解析成的IP是127.0.0.1,127.0.0.1永远指向本地</span></span><br><span class="line"> InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;localhost&quot;</span>,<span class="number">8090</span>);</span><br><span class="line"> <span class="comment">//获取IP地址</span></span><br><span class="line"> System.out.println(isa.getAddress());</span><br><span class="line"> <span class="comment">//获取主机名</span></span><br><span class="line"> System.out.println(isa.getHostName());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UDP</p><p>发送端</p><ol><li><p>创建UDP发送端对象</p></li><li><p>创建数据包，准备数据并指定ip和端口号</p></li><li><p>发送数据包</p></li><li><p>关流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.net.udp;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建UDP发送端的对象</span></span><br><span class="line"> DatagramSocket ds=<span class="keyword">new</span> DatagramSocket();</span><br><span class="line"> <span class="comment">//创建数据包对象---来发送数据</span></span><br><span class="line"> <span class="comment">//第一个参数---字节数组---准备的要传输的数据</span></span><br><span class="line"> <span class="comment">//第二个参数---长度---真实要传输的数据的长度（小于等于数据长度）</span></span><br><span class="line"> <span class="comment">//第三个参数---对象---指定IP和端口号</span></span><br><span class="line"> DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(<span class="string">&quot;你好&quot;</span>.getBytes(),</span><br><span class="line"> <span class="string">&quot;你好&quot;</span>.getBytes().length,</span><br><span class="line"> <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8091</span>));</span><br><span class="line"> <span class="comment">//发送数据包</span></span><br><span class="line"> ds.send(dp);</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> ds.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><p>接收端</p><ol><li><p>创建UDP接受对象并且监听端口号</p></li><li><p>创建数据包来接受数据</p></li><li><p>接受数据</p></li><li><p>关流</p></li><li><p>解析数据包里的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.net.udp;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建UDP接收端对象---监听端口号</span></span><br><span class="line"> DatagramSocket ds=<span class="keyword">new</span> DatagramSocket(<span class="number">8091</span>);</span><br><span class="line"> <span class="comment">//创建数据包对象来接收数据</span></span><br><span class="line"> <span class="comment">//第一个参数代表新建字节数组来接收传过来的字节数据</span></span><br><span class="line"> <span class="comment">//第二个参数就是指定新建的字节数组可以接收多少内容</span></span><br><span class="line"> DatagramPacket dp=<span class="keyword">new</span> DatagramPacket(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>],<span class="number">10</span>);</span><br><span class="line"> <span class="comment">//接收数据</span></span><br><span class="line"> ds.receive(dp);<span class="comment">//让线程对象发生阻塞</span></span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> ds.close();</span><br><span class="line"> <span class="comment">//解析数据</span></span><br><span class="line"> System.out.println(dp.getAddress());<span class="comment">//获取IP</span></span><br><span class="line"> <span class="comment">//getData()返回接收的数据，getlength()返回接收数据的长度</span></span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(dp.getData(),<span class="number">0</span>,dp.getLength()));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>TCP</p><p>​     底层基于流</p><p>​     传输需要建立连接（三次握手），传输过程安全，但是传输效率较低</p><p>​    底层是根据字节流来进行数据传输的 （理论上不限制传输数据的大小）</p><p>​    适用场景：聊天、文件上传和下载 等等</p><p>​     Socket,ServerScoket</p><p>客户端</p><ol><li><p>创建TCP客户端对象</p></li><li><p>发起连接</p></li><li><p>获取自带的字节流</p></li><li><p>写出数据</p></li><li><p>通知服务器端数据已经写出完毕</p></li><li><p>关流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.net.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClientDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建TCP客户端对象</span></span><br><span class="line"> Socket s=<span class="keyword">new</span> Socket();</span><br><span class="line"> <span class="comment">//发起连接</span></span><br><span class="line"> s.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9098</span>));<span class="comment">//让线程对象产生阻塞</span></span><br><span class="line"> <span class="comment">//获取自带的字节输出流</span></span><br><span class="line"> <span class="comment">//不需要指定路径信息默认写到服务器端</span></span><br><span class="line"> OutputStream os = s.getOutputStream();</span><br><span class="line"> <span class="comment">//写出数据</span></span><br><span class="line"> os.write(<span class="string">&quot;你好！！！&quot;</span>.getBytes());</span><br><span class="line"> <span class="comment">//通知服务器端数据已经发送完毕(关闭字节输出流的通道)</span></span><br><span class="line"> s.shutdownOutput();</span><br><span class="line"> <span class="comment">//读取服务器端发送的数据</span></span><br><span class="line"> <span class="comment">//获取自带字节输入流</span></span><br><span class="line"> InputStream is = s.getInputStream();</span><br><span class="line"> <span class="comment">//读取数据</span></span><br><span class="line"> <span class="keyword">byte</span>[] bs=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line"> <span class="keyword">int</span> len=-<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> ((len=is.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(bs,<span class="number">0</span>,len));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//通知服务器端数据已经接收完毕</span></span><br><span class="line"> s.shutdownInput();</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> s.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>服务器端</p><ol><li><p>创建TCP服务器端对象并且监听端口号</p></li><li><p>接受连接</p></li><li><p>获取自带的字节输入流</p></li><li><p>读取数据</p></li><li><p>通知客户端数据已经接受完毕</p></li><li><p>关流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.net.tcp;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建TCP服务器端的对象---监听端口号</span></span><br><span class="line"> ServerSocket ss=<span class="keyword">new</span> ServerSocket(<span class="number">9098</span>);</span><br><span class="line"><span class="comment">//接收连接</span></span><br><span class="line"> Socket s = ss.accept();<span class="comment">//返回Socket类型的对象才能获取自带的字节流</span></span><br><span class="line"> <span class="comment">//让线程对象产生阻塞</span></span><br><span class="line"> <span class="comment">//获取自带的字节输入流</span></span><br><span class="line"> InputStream is = s.getInputStream();</span><br><span class="line"> <span class="comment">//读数据</span></span><br><span class="line"> <span class="keyword">byte</span>[] bs=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line"> <span class="keyword">int</span> len=<span class="number">1</span>-<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">while</span> ((len=is.read(bs))!=-<span class="number">1</span>)&#123;<span class="comment">//让线程对象产生阻塞</span></span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(bs,<span class="number">0</span>,len));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//通知客户端数据已经读取完毕(关闭自带的字节输入流)</span></span><br><span class="line"> s.shutdownInput();</span><br><span class="line"> <span class="comment">//往客户端发送数据</span></span><br><span class="line"> <span class="comment">/*//获取自带字节输出流（默认往客户端来写出数据）</span></span><br><span class="line"><span class="comment"> OutputStream os = s.getOutputStream();</span></span><br><span class="line"><span class="comment"> //写出数据</span></span><br><span class="line"><span class="comment"> os.write(&quot;你也好！！！&quot;.getBytes());</span></span><br><span class="line"><span class="comment"> //通知客户端数据已经发送完毕</span></span><br><span class="line"><span class="comment"> s.shutdownOutput();*/</span></span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> s.close();</span><br><span class="line"> ss.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>让线程对象产生阻塞的方法：receive()、connect()、accept()、read()、write()</p><p>​        </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;   &lt;strong&gt;优先级（当作权重来尽量避免死锁的发生）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​        优先级1-10，优先级越大的</summary>
      
    
    
    
    
    <category term="线程 网络编程 聊天室" scheme="http://senye.ink/tags/%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>day26</title>
    <link href="http://senye.ink/2021/07/26/day26/"/>
    <id>http://senye.ink/2021/07/26/day26/</id>
    <published>2021-07-26T13:36:17.170Z</published>
    <updated>2021-07-26T13:40:35.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>多个模块之间产生了关联—耦合度</p><p>service层： 可以读取配置文件的内容中的字符串内容，可以通过技术来把字符串内容解析成对应的类从而创建对象—这门技术就是反射</p><p>  概念：</p><p>​           解析类，由字节码对象来获取实例对象的过程—反射（发生在运行时期）</p><p>​    Class— 代表类的类   创建的对象就是具体的类（一个具体的类就等效于一个.class文件对应一个字节码对象）</p><p>​    Method—代表方法的类  创建的对象就是具体的方法</p><p>​    Fild—代表属性的类  创建对象就是具体的属性</p><p>​    Constructor—代表构造方法的类   创建的对象就是具体的构造方法</p><p>​    Package— 代表包的类  创建对象就是具体的包</p><h4 id="获取字节码对象"><a href="#获取字节码对象" class="headerlink" title="获取字节码对象"></a>获取字节码对象</h4><ol><li><p>通过数据类型.class来获取字节码对象</p></li><li><p>通过对象去调用getClass()来返回字节码对象</p></li><li><p>把字符串内容传入到forName静态方法中来返回字节码对象（保证字符串内容没有问题）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"> <span class="comment">//1.通过数据类型.class来获取字节码对象</span></span><br><span class="line"> <span class="comment">/*//返回的是String类的字节码对象</span></span><br><span class="line"><span class="comment"> Class&lt;String&gt; clz = String.class;</span></span><br><span class="line"><span class="comment"> //返回的是List接口的字节码对象</span></span><br><span class="line"><span class="comment"> Class&lt;List&gt; clz1 = List.class;</span></span><br><span class="line"><span class="comment"> //返回的是char数组的字节码对象</span></span><br><span class="line"><span class="comment"> Class&lt;char[]&gt; clz2 = char[].class;</span></span><br><span class="line"><span class="comment"> //返回的是int的字节码对象</span></span><br><span class="line"><span class="comment"> Class clz3=int.class;</span></span><br><span class="line"><span class="comment"> System.out.println(clz);*/</span></span><br><span class="line"> <span class="comment">//2.对象.getClass()返回字节码对象</span></span><br><span class="line"> <span class="comment">/* Class&lt;String&gt; clz= (Class&lt;String&gt;) &quot;abc&quot;.getClass();</span></span><br><span class="line"><span class="comment"> System.out.println(clz);*/</span></span><br><span class="line"> <span class="comment">//3.通过字符串内容来获取字节码对象</span></span><br><span class="line"> Class&lt;String&gt; clz= (Class&lt;String&gt;) Class.forName(<span class="string">&quot;java.lang.String&quot;</span>);</span><br><span class="line"> System.out.println(clz);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h4 id="获取实例对象"><a href="#获取实例对象" class="headerlink" title="获取实例对象"></a>获取实例对象</h4><ol><li><p>字节码对象调用newInstance无参方法默认调用无参构造来返回实例对象</p></li><li><p>先获取有参构造，再通过构造方法类的对象调用newInstance有参方法来给有参构造进行赋值最后返回实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//字节码对象</span></span><br><span class="line"> Class&lt;String&gt; clz = String.class;</span><br><span class="line"> <span class="comment">//通过字节码对象来获取实例对象</span></span><br><span class="line"> <span class="comment">//newInstance()---默认调用无参构造来构建实例对象</span></span><br><span class="line"> <span class="comment">//String s = clz.newInstance();</span></span><br><span class="line"> <span class="comment">//通过字节码对象来获取指定的有参构造</span></span><br><span class="line"> <span class="comment">//Constructor类的对象就是一个具体构造方法</span></span><br><span class="line"> Constructor&lt;String&gt; c = clz.getConstructor(String.class);</span><br><span class="line"> <span class="comment">//通过构造方法类的对象调用newInstance有参方法来给有参构造来赋值并且返回实例对象</span></span><br><span class="line"> String s = c.newInstance(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> System.out.println(s);</span><br><span class="line"> <span class="comment">//调用Integer有参构造来返回实例对象</span></span><br><span class="line"> <span class="comment">//获取字节码对象</span></span><br><span class="line"> Class&lt;Integer&gt; clz1 = Integer.class;</span><br><span class="line"> <span class="comment">//通过字节码对象来获取有参构造</span></span><br><span class="line"> Constructor&lt;Integer&gt; c1 = clz1.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"> <span class="comment">//通过构造方法类调用方法返回实例对象</span></span><br><span class="line"> Integer in = c1.newInstance(<span class="number">123</span>);</span><br><span class="line"> System.out.println(in);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li><p>打破了封装原则</p></li><li><p>跳过泛型法类型检测</p></li></ol><h4 id="jdk新特性（1-5）"><a href="#jdk新特性（1-5）" class="headerlink" title="jdk新特性（1.5）"></a>jdk新特性（1.5）</h4><p>静态导入</p><p>​      可以把静态方法进行导入就可以直接使用</p><p>​      静态导入的方法先加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo2</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException,</span></span><br><span class="line"><span class="function">InvocationTargetException </span>&#123;</span><br><span class="line"> <span class="comment">//字节码对象</span></span><br><span class="line"> Class&lt;String&gt; clz = String.class;</span><br><span class="line"> <span class="comment">//通过字节码对象来获取实例对象</span></span><br><span class="line"> <span class="comment">//newInstance()---默认调用无参构造来构建实例对象</span></span><br><span class="line"> <span class="comment">//String s = clz.newInstance();</span></span><br><span class="line"> <span class="comment">//通过字节码对象来获取指定的有参构造</span></span><br><span class="line"> <span class="comment">//Constructor类的对象就是一个具体构造方法</span></span><br><span class="line"> Constructor&lt;String&gt; c = clz.getConstructor(String.class);</span><br><span class="line"> <span class="comment">//通过构造方法类的对象调用newInstance有参方法来给有参构造来赋值并且返回实例对象</span></span><br><span class="line"> String s = c.newInstance(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> System.out.println(s);</span><br><span class="line"> <span class="comment">//调用Integer有参构造来返回实例对象</span></span><br><span class="line"> <span class="comment">//获取字节码对象</span></span><br><span class="line"> Class&lt;Integer&gt; clz1 = Integer.class;</span><br><span class="line"> <span class="comment">//通过字节码对象来获取有参构造</span></span><br><span class="line"> Constructor&lt;Integer&gt; c1 = clz1.getConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"> <span class="comment">//通过构造方法类调用方法返回实例对象</span></span><br><span class="line"> Integer in = c1.newInstance(<span class="number">123</span>);</span><br><span class="line"> System.out.println(in);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数</p><p>​       参数类型…</p><p>​       可以接收任意多个参数值</p><p>​       底层根据数据来实现的</p><p>​       只能出现在参数列表的最右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VariableDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line"> System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"> System.out.println(sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//参数类型...---可变参数</span></span><br><span class="line"> <span class="comment">//可以接收任意多个参数（要和参数类型统一）</span></span><br><span class="line"> <span class="comment">//可变参数底层是由数组来实现的，数组的每个元素来接收对应接收的参数值</span></span><br><span class="line"> <span class="comment">//可变参数只能出现在最右边</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... x)</span></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> a:x)&#123;</span><br><span class="line"> sum+=a;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/*public static int sum(int x,int y,int z)&#123;</span></span><br><span class="line"><span class="comment"> return x+y+z;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> public static int sum(int[] arr)&#123;</span></span><br><span class="line"><span class="comment"> int sum=0;</span></span><br><span class="line"><span class="comment"> for(int a:arr)&#123;</span></span><br><span class="line"><span class="comment"> sum+=a;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> return sum;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>​        将值一一列举</p><p>​       枚举常量要在一行并且首行</p><p>​       可以定义属性和普通方法</p><p>​       定义的构造方法只能是私有化的</p><p>​       可以定义抽象方法</p><p>​       从jdk1.5开始switch的表达式支持枚举类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//调用静态属性---对象</span></span><br><span class="line"> Season spring = Season.spring;</span><br><span class="line"> <span class="comment">//表达式支持枚举类型</span></span><br><span class="line"> <span class="keyword">switch</span> (spring)&#123;</span><br><span class="line"> <span class="keyword">case</span> spring:</span><br><span class="line"> System.out.println(<span class="string">&quot;春游&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> summer:</span><br><span class="line"> System.out.println(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> autumn:</span><br><span class="line"> System.out.println(<span class="string">&quot;秋游&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> winter:</span><br><span class="line"> System.out.println(<span class="string">&quot;冬眠&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//枚举类</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Season</span></span>&#123;</span><br><span class="line"> <span class="comment">//枚举常量</span></span><br><span class="line"> <span class="comment">//sring等效于public static final Season spring=new Season();</span></span><br><span class="line"> <span class="comment">//枚举常量只能在同一行并且是首行</span></span><br><span class="line"> spring&#123;<span class="comment">//使用匿名内部类去默认实现重写方法</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,summer &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,autumn &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;,winter &#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"> <span class="comment">//定义属性</span></span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="comment">//定义构造方法只能是私有化的构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> <span class="comment">//定义方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"> <span class="comment">//定义抽象方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">n</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类代表季节---一年四季---类只能创建四个对象</span></span><br><span class="line"><span class="comment">/*class Season&#123;</span></span><br><span class="line"><span class="comment"> //私有化构造方法</span></span><br><span class="line"><span class="comment"> private Season()&#123;&#125;</span></span><br><span class="line"><span class="comment"> //创建四个对象</span></span><br><span class="line"><span class="comment"> public static final Season spring=new Season();</span></span><br><span class="line"><span class="comment"> public static final Season summer=new Season();</span></span><br><span class="line"><span class="comment"> public static final Season autumn=new Season();</span></span><br><span class="line"><span class="comment"> public static final Season winter=new Season();</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br></pre></td></tr></table></figure><p>​       </p><p>jdk1.8新特性</p><p>​     接口中支持定义实体方法（可以用default或者static来修饰的方法）</p><p>​     Lambda表达式默认实现函数式接口类重写抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.jdk.jdk8;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"><span class="keyword">import</span> java.io.FilenameFilter;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建实现类对象可以调用接口中的实体方法</span></span><br><span class="line"> <span class="comment">/* CalcImpl c=new CalcImpl();</span></span><br><span class="line"><span class="comment"> System.out.println(c.sum(1,2));</span></span><br><span class="line"><span class="comment"> //接口名.调用静态实体方法</span></span><br><span class="line"><span class="comment"> System.out.println(Calc.jc(3,4));*/</span></span><br><span class="line"> <span class="comment">//匿名内部类默认重写抽象方法并创建匿名内部类的对象调用重写方法</span></span><br><span class="line"> <span class="comment">/* System.out.println(new Calc() &#123;</span></span><br><span class="line"><span class="comment"> @Override</span></span><br><span class="line"><span class="comment"> public int max(int m, int n) &#123;</span></span><br><span class="line"><span class="comment"> return m&gt;n?m:n;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> &#125;.max(2,3));*/</span></span><br><span class="line"> <span class="comment">//Lambda表达式</span></span><br><span class="line"> <span class="comment">//(参数列表)-&gt;&#123;重写方法体&#125;</span></span><br><span class="line"> <span class="comment">//Calc c=(int m,int n)-&gt;&#123;return m&gt;n?m:n;&#125;;</span></span><br><span class="line"> <span class="comment">//参数类型可以由前推导出来所以可以省略不写，如果方法体只有一句话可以省略return和&#123;&#125;不写</span></span><br><span class="line"> <span class="comment">//保证接口中只有一个抽象方法才能使用</span></span><br><span class="line"> Calc c=(m,n)-&gt;m&gt;n?m:n;</span><br><span class="line"> System.out.println(c.max(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义代表计算器的接口</span></span><br><span class="line"><span class="comment">//函数式接口（只能有一个抽象方法）---函数式编程</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Calc</span></span>&#123;</span><br><span class="line"> <span class="comment">//求大小(抽象方法)</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> m,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"> <span class="comment">//用default修饰的实体方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x+y;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//用static修饰的实体方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">jc</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x*y;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalcImpl</span> <span class="keyword">implements</span> <span class="title">Calc</span></span>&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> m&gt;n?m:n;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Stream—流式结构</p><p>   流式操作集合元素</p><p>   提供大量的函数式接口（可以使用Lambda表达式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> list.add(<span class="string">&quot;Python&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;JAVA&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;C#&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;PHP&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;C++&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;GO&quot;</span>);</span><br><span class="line"> <span class="comment">/*//过滤出以C开头元素</span></span><br><span class="line"><span class="comment"> for(String s:list)&#123;</span></span><br><span class="line"><span class="comment"> //判断是否以C开头</span></span><br><span class="line"><span class="comment"> if(s.startsWith(&quot;C&quot;))&#123;</span></span><br><span class="line"><span class="comment"> System.out.println(s);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="comment">//调用方法返回流失结构</span></span><br><span class="line"> Stream&lt;String&gt; s = list.stream();</span><br><span class="line"> <span class="comment">//过滤</span></span><br><span class="line"> <span class="comment">//过滤出以C开头元素</span></span><br><span class="line"> <span class="comment">/* s.filter(new Predicate&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment"> //重写指定过滤规则</span></span><br><span class="line"><span class="comment"> @Override</span></span><br><span class="line"><span class="comment"> public boolean test(String s) &#123;//参数就是传入的集合存储的内容</span></span><br><span class="line"><span class="comment"> return s.startsWith(&quot;C&quot;);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> &#125;).forEach(new Consumer&lt;String&gt;() &#123;</span></span><br><span class="line"><span class="comment"> @Override</span></span><br><span class="line"><span class="comment"> public void accept(String s) &#123;//参数就是过滤之后的数据</span></span><br><span class="line"><span class="comment"> System.out.println(s);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> &#125;);*/</span></span><br><span class="line"> <span class="comment">//Lambda表达式来实现(一个参数可以省略()不写)</span></span><br><span class="line"> <span class="comment">//过滤出以C开头元素并且排序(字典)</span></span><br><span class="line"> s.filter(s1-&gt;s1.startsWith(<span class="string">&quot;C&quot;</span>)).sorted((o1,o2)-&gt;o2.compareTo(o1)).forEach(s2-&gt; System.out.println(s2));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h2&gt;&lt;p&gt;多个模块之间产生了关联—耦合度&lt;/p&gt;
&lt;p&gt;service层： 可以读取配置文件的内容中的字符串内容，可以通过技术来把字符串内容解析成对应</summary>
      
    
    
    
    
    <category term="反射 jdk特性" scheme="http://senye.ink/tags/%E5%8F%8D%E5%B0%84-jdk%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>day24</title>
    <link href="http://senye.ink/2021/07/22/day24/"/>
    <id>http://senye.ink/2021/07/22/day24/</id>
    <published>2021-07-22T12:56:55.604Z</published>
    <updated>2021-07-22T12:58:07.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>​      线程之间存在相互抢占CPU执行权（随机） 发生在代码的每一步，导致程序出现错乱数据（重复、跳过、负数等等）</p><p>​     <strong>多线程并发安全问题（枷锁）</strong></p><h5 id="同步代码块锁"><a href="#同步代码块锁" class="headerlink" title="同步代码块锁"></a>同步代码块锁</h5><p>​      synchronized（锁对象）{线程核心内容}</p><p>​     根据锁对象来共享线程对象，被共享进来的线程对象可以保证执行代码块里的线程核心内容时每次只能出现一个线程对象，就可以避免线程核心内容出现抢占的问题</p><h5 id="锁对象"><a href="#锁对象" class="headerlink" title="锁对象"></a>锁对象</h5><p>​    可以把当前参与的线程对象共享进来</p><p>​    方法区资源（可以共享所有的线程对象）</p><p>​    this（前提是参与的线程对象共享Runna‘实现类对象）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建seller的对象  -----代表四个售票员</span></span><br><span class="line">        Ticket t=<span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="comment">//设置剩余票数</span></span><br><span class="line">        t.setCount(<span class="number">100</span>);</span><br><span class="line">        Seller s1=<span class="keyword">new</span> Seller(t);</span><br><span class="line">        Seller s2=<span class="keyword">new</span> Seller(t);</span><br><span class="line">        Seller s3=<span class="keyword">new</span> Seller(t);</span><br><span class="line">        Seller s4=<span class="keyword">new</span> Seller(t);</span><br><span class="line">        <span class="comment">//创建四个线程对象 并指定名字</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(s1,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(s2,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(s3,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> Thread(s4,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//定义类---，描述线程任务信息 卖票</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Seller</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="comment">//代表票数</span></span><br><span class="line">        <span class="comment">//int ticket = 100;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写run方法---指定卖票过程</span></span><br><span class="line">        <span class="comment">//重写run方法----指定卖票过程</span></span><br><span class="line">        <span class="comment">//声明代表票类的对象</span></span><br><span class="line">        Ticket t;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有参构造(保证共卖100张票---保证创建的所有的Seller类的对象共享同一个Ticket类的对象)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Seller</span><span class="params">(Ticket t)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.t = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//循环要执行但是不能写结束条件</span></span><br><span class="line">            <span class="comment">//同步代码块锁</span></span><br><span class="line">            <span class="comment">//去包住代码块的核心内容</span></span><br><span class="line">            <span class="comment">//（）----锁对象（可以把线程对象共享进来的对象）</span></span><br><span class="line">             <span class="comment">/*  synchronized( Seller.class) Math.class String.class</span></span><br><span class="line"><span class="comment">             方法区的资源（可以共享所有的线程对象）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">            <span class="keyword">synchronized</span> (t) &#123;<span class="comment">//可以把当前参与的所有线程对象共享进来</span></span><br><span class="line">                    <span class="comment">//结束循环的条件</span></span><br><span class="line">                <span class="keyword">if</span> (t.getCount()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    <span class="comment">//票数减一并且设置新的值</span></span><br><span class="line">                    t.setCount(t.getCount() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//输出对象的名字</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了一张 还剩&quot;</span> + t.getCount() + <span class="string">&quot;张&quot;</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义代表票的类</span></span><br><span class="line">     <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>&#123;</span><br><span class="line">        <span class="comment">//属性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//代表票数</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="同步方法锁"><a href="#同步方法锁" class="headerlink" title="同步方法锁"></a>同步方法锁</h5><p>​    在方法上加上synchronized关键字来修饰方法，会默认提供锁对象来共享线程，共享进来的线程对       象在执行方法内容时可以保证只能每次有一个线程对象来执行。</p><p>​    如果修饰的是非静态方法默认的锁对象是this</p><p>​    如果修饰的是静态方法默认的锁对象是当前类.class（方法区资源可以共享所有线程）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建seller的对象  -----代表四个售票员</span></span><br><span class="line">        Ticket t=<span class="keyword">new</span> Ticket();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置剩余票数</span></span><br><span class="line">        t.setCount(<span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建Seller类的对象--带代表一个售票系统</span></span><br><span class="line">        Seller1 s=<span class="keyword">new</span> Seller1(t);<span class="comment">//Runnable实现类对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建四个线程对象 并指定名字</span></span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(s,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(s,<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        Thread t3=<span class="keyword">new</span> Thread(s,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        Thread t4=<span class="keyword">new</span> Thread(s,<span class="string">&quot;d&quot;</span>);</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">        t4.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seller1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//代表票数</span></span><br><span class="line">    <span class="comment">//int ticket = 100;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写run方法---指定卖票过程</span></span><br><span class="line">    <span class="comment">//重写run方法----指定卖票过程</span></span><br><span class="line">    <span class="comment">//声明代表票类的对象</span></span><br><span class="line">    Ticket t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造(保证共卖100张票---保证创建的所有的Seller类的对象共享同一个Ticket类的对象)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Seller1</span><span class="params">(Ticket t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//循环要执行但是不能写结束条件</span></span><br><span class="line">            <span class="comment">//同步代码块锁</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">//去包住代码块的核心内容</span></span><br><span class="line">            <span class="comment">//（）----锁对象（可以把线程对象共享进来的对象）</span></span><br><span class="line">             <span class="comment">/*  synchronized( Seller.class) Math.class String.class</span></span><br><span class="line"><span class="comment">             方法区的资源（可以共享所有的线程对象）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">          <span class="comment">//  synchronized (t) &#123;//可以把当前参与的所有线程对象共享进来</span></span><br><span class="line">                <span class="comment">//结束循环的条件</span></span><br><span class="line">                <span class="keyword">if</span> (t.getCount()==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//票数减一并且设置新的值</span></span><br><span class="line">                t.setCount(t.getCount() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//输出对象的名字</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;买了一张 还剩&quot;</span> + t.getCount() + <span class="string">&quot;张&quot;</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>​     同步：在某个时刻只能一个线程对象来访问资源（没有抢占）</p><p>​     异步：在某个时刻多个线程之间可以互相抢占资源（有抢占）</p><p>​    同步一定是安全，不安全的一定是异步。 </p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>是由锁的嵌套来产生的，通过死锁检测来让其中一个线程对象先执行，资源就可以释放，就解决了死锁的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.NoSuchElementException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建静态对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Printer p=<span class="keyword">new</span> Printer();</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Scaner s=<span class="keyword">new</span> Scaner();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示第一个员工（先打印  再扫描）</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//先打印</span></span><br><span class="line">                <span class="keyword">synchronized</span> (p)&#123;</span><br><span class="line">                    p.print();</span><br><span class="line">                    <span class="comment">//休息</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//在扫描</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (s)&#123;</span><br><span class="line">                        s.scan();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//第二个员工（先扫描 再打印）</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//先扫描</span></span><br><span class="line">                <span class="keyword">synchronized</span> (s)&#123;</span><br><span class="line">                   s.scan();</span><br><span class="line">                    <span class="comment">//休眠</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (p)&#123;</span><br><span class="line">                       p.print();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义代表打印机的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Printer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在打印。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义代表扫描的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scaner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scan</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在扫描。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="生产消费模型"><a href="#生产消费模型" class="headerlink" title="生产消费模型"></a>生产消费模型</h5><p>​    每次生产的商品数量是随机数且每次总的剩余量不能超过1000，每次消费的商品数量是随机数，要求生产和消费交替执行（生产和消费一直执行不要停）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProConDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建代表商品类的对象</span></span><br><span class="line">        Productor p = <span class="keyword">new</span> Productor();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//开启线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer(p)).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer(p)).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> Productor p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造 （保证共享同一个类的对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Productor p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.getFlag() == <span class="keyword">true</span>)</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        p.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//生产的最大值</span></span><br><span class="line">                <span class="keyword">int</span> max = <span class="number">1000</span> - p.getCount();</span><br><span class="line">                <span class="comment">//随机生产商品（0——max可以取到）</span></span><br><span class="line">                <span class="keyword">int</span> count = (<span class="keyword">int</span>) (Math.random() * (max + <span class="number">1</span>));</span><br><span class="line">                <span class="comment">//设置最新的剩余商品数量</span></span><br><span class="line">                p.setCount(p.getCount() + count);</span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;生产了&quot;</span> + count + <span class="string">&quot;个 剩余&quot;</span> + p.getCount() + <span class="string">&quot;个商品&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//唤醒等待的线程对象</span></span><br><span class="line">                p.notify();</span><br><span class="line">                <span class="comment">//改变boolean值</span></span><br><span class="line">                p.notifyAll();</span><br><span class="line">                p.setFlag(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Productor p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造 （保证共享同一个类的对象）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Productor p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.p = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p.getFlag() == <span class="keyword">false</span>)</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        p.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="comment">//消费的随机商品数量（0-p.getCount()    取到最大值）</span></span><br><span class="line">                <span class="keyword">int</span> count = (<span class="keyword">int</span>) (Math.random() * (p.getCount() + <span class="number">1</span>));</span><br><span class="line">                <span class="comment">//设置最新的商品剩余数量</span></span><br><span class="line">                p.setCount(p.getCount() - count);</span><br><span class="line">                <span class="comment">//输出</span></span><br><span class="line">                System.out.println(<span class="string">&quot;消费了&quot;</span> + count + <span class="string">&quot;个 剩余&quot;</span> + p.getCount() + <span class="string">&quot;个商品&quot;</span>);</span><br><span class="line">                <span class="comment">//唤醒等待的线程对象</span></span><br><span class="line">                p.notify();</span><br><span class="line">                p.setFlag(<span class="keyword">false</span>);</span><br><span class="line">                p.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标志位</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCount</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等待唤醒机制（结合锁来使用）</p><p>  通过wait方法、notify方法、notifyAll方法以及标致为来控制线程对象的执行轨迹</p><p>sleep方法和wait方法</p><ol><li>sleep方法可以指定休眠的时间到点自然醒，在休眠期间sleep方法来释放线程对象的cpu执行权。定义在Thread类里的静态方法。</li><li>wait方法可以指定等待时间 也可以不指定 如果指定了等待时间也是到点自然醒 如果没有指定等待时间就需要手动唤醒，在等待期间释放线程对象的cpu执行权以及释放锁对象（可以抢占），定义在object类里（可以保证被锁对象来调用）。</li></ol><h5 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h5><ol><li>新建</li><li>就绪</li><li>执行</li><li>销毁</li><li>阻塞</li></ol><p>​                                                                                       </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;​      线程之间存在相互抢占CPU执行权（随机） 发生在代码的每一步，导致程序出现错乱数据（重复、跳过、负数等等）&lt;/p&gt;
&lt;p&gt;​ </summary>
      
    
    
    
    
    <category term="线程 同步异步" scheme="http://senye.ink/tags/%E7%BA%BF%E7%A8%8B-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>day23</title>
    <link href="http://senye.ink/2021/07/21/day23/"/>
    <id>http://senye.ink/2021/07/21/day23/</id>
    <published>2021-07-21T12:32:24.668Z</published>
    <updated>2021-07-21T12:33:02.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io流"><a href="#io流" class="headerlink" title="io流"></a>io流</h1><p>根据传输方向和传输形式共同形成四大基本流（其他流都是从基本流衍生出来的）</p><p>字符流（针对硬盘文件的输入和输出）</p><p>​     FileWriter（底层带有缓存区 存满才能传输）</p><p>​     FileReader （底层没有缓冲区  可以自建缓冲区来提供读取效率）</p><p>字节流（针对硬盘文件的输入和输出）</p><p>​     FileOutputStream（底层没有缓冲区）</p><p>​     FileInputStream  （底层没有缓冲区  可以自建缓冲区来提供读取效率）</p><p>缓冲流（给其他提供缓冲区）</p><h3 id="系统流"><a href="#系统流" class="headerlink" title="系统流"></a>系统流</h3><p>​    out err in  (都是静态的字节流对象)</p><p>​    系统流使用完毕不能去关流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.io.system;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//out---字节输出流对象</span></span><br><span class="line"> System.out.println(<span class="number">1</span>);<span class="comment">//输出正常结果</span></span><br><span class="line"> <span class="comment">//err---字节输出流对象</span></span><br><span class="line"> System.err.println(<span class="number">1</span>);<span class="comment">//输出错误结果</span></span><br><span class="line"> <span class="comment">//in---字节输入流对象</span></span><br><span class="line"> Scanner sc1=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> i1 = sc1.nextInt();</span><br><span class="line"> <span class="comment">//in是静态对象，全局共享同一个静态对象，如果关闭流通道。那么其他地方在使用的键盘录入都会关闭</span></span><br><span class="line"> sc1.close();</span><br><span class="line"> System.out.println(i1);</span><br><span class="line"> Scanner sc2=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"> <span class="keyword">int</span> i2 = sc1.nextInt();</span><br><span class="line"> System.out.println(i2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="转换流-（实现字节流和字符流的相互转换）"><a href="#转换流-（实现字节流和字符流的相互转换）" class="headerlink" title="转换流  （实现字节流和字符流的相互转换）"></a>转换流  （实现字节流和字符流的相互转换）</h3><p>   <strong>OutoutStreamWriter —-字符流转成字节流</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.io.transform;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutputStreamWriterDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建转换流对象</span></span><br><span class="line"> <span class="comment">//底层真正做数据传输的是文件字节输出流</span></span><br><span class="line"> <span class="comment">//首先自动提供字符流来存放字符形式的数据再根据底层文件字节流来做数据传输</span></span><br><span class="line"> <span class="comment">//转换流---字符流转成字节流</span></span><br><span class="line"> OutputStreamWriter osw=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;D:\\1.txt&quot;</span>));</span><br><span class="line"> <span class="comment">//写出数据</span></span><br><span class="line"> <span class="comment">//首先要准备数据---字符形式的数据---只能自动提供字符流来存放字符形式的数据</span></span><br><span class="line"> osw.write(<span class="string">&quot;上午好&quot;</span>);</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> osw.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   InputStreamreader—-字节流转成字符流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.io.transform;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReaderDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建转换流对象</span></span><br><span class="line"> <span class="comment">//底层是根据文件字节输入流来传输数据</span></span><br><span class="line"> <span class="comment">//首先根据文件字节输入流来读取数据，再是自动提供字符流来展示字符形式的数据</span></span><br><span class="line"> <span class="comment">//转换流是把字节流转成字符流</span></span><br><span class="line"> InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;D:\\3.txt&quot;</span>));</span><br><span class="line"> <span class="comment">//读取数据</span></span><br><span class="line"> <span class="keyword">int</span> len=-<span class="number">1</span>;</span><br><span class="line"> <span class="keyword">char</span>[] cs=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"> <span class="comment">//展示数据的形式是字符形式的数据---自动提供字符流来接收</span></span><br><span class="line"> <span class="keyword">while</span> ((len=isr.read(cs))!=-<span class="number">1</span>)&#123;</span><br><span class="line"> System.out.println(<span class="keyword">new</span> String(cs,<span class="number">0</span>,len));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> isr.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>序列化与反序列化</strong></p><p>​    <strong>序列化</strong>：把对象以及相关的信息转成字节数组  把字节数组的内容最终存储在硬盘中—持久化</p><p>​    <strong>反序列化：</strong>把字节数组转成对应的对象 </p><p><strong>注意</strong></p><ol><li><p>类实现Serilizable产生的对象才支持序列化</p></li><li><p>可以把属性序列化过去但是不能序列化方法</p></li><li><p>被ststic修饰的属性或者被transient修饰的属性不能被序列化过去</p></li><li><p>serialVersionUID—序列化版本号  在序列化之前会根据当前类的属性和方法计算出一个序列化版本号 这个版本号会随着对象信息一起序列化获取 在反序列化之前再次根据当前类的属性和方法计算出一个版本号，拿着两个版本号来进行比较如果相同则反序列化成功   如果不相同 则反序列化失败。</p></li><li><p>集合和映射的对象都不能直接进行序列化，只能一次遍历集合或者映射来序列化集合或者映射的元素对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建对象</span></span><br><span class="line"> <span class="comment">//路径信息没有指定盘符就是存放在当前工程里</span></span><br><span class="line"> ObjectOutputStream oos=<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;p.data&quot;</span>));</span><br><span class="line"> <span class="comment">//提供对象</span></span><br><span class="line"> Person p=<span class="keyword">new</span> Person();</span><br><span class="line"> p.setName(<span class="string">&quot;lili&quot;</span>);</span><br><span class="line"> p.setAge(<span class="number">18</span>);</span><br><span class="line"> <span class="comment">//序列化---对象转成字节信息</span></span><br><span class="line"> oos.writeObject(p);</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> oos.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStreamDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"> <span class="comment">//创建对象</span></span><br><span class="line"> ObjectInputStream ois=<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;p.data&quot;</span>));</span><br><span class="line"> <span class="comment">//反序列化---把字节数组转成对象</span></span><br><span class="line"> <span class="comment">//读取文件里的字节信息转成对象</span></span><br><span class="line"> Person p= (Person) ois.readObject();</span><br><span class="line"> <span class="comment">//关流</span></span><br><span class="line"> ois.close();</span><br><span class="line"> <span class="comment">//展示数据</span></span><br><span class="line"> System.out.println(p.getName()+<span class="string">&quot;,&quot;</span>+p.getAge());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>Properties</p><p>  父类是Hashtable 支持持久化（支持序列化）</p><p>  映射类的键和值的类型都是String类型</p><p>当作配置文件来使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.properties;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建对象</span></span><br><span class="line"> Properties p=<span class="keyword">new</span> Properties();</span><br><span class="line"> <span class="comment">//往映射添加元素(键和值的类型都是String类型)</span></span><br><span class="line"> p.setProperty(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lili&quot;</span>);</span><br><span class="line"> p.setProperty(<span class="string">&quot;age&quot;</span>,<span class="string">&quot;18&quot;</span>);</span><br><span class="line"> p.setProperty(<span class="string">&quot;gender&quot;</span>,<span class="string">&quot;female&quot;</span>);</span><br><span class="line"> <span class="comment">//序列化（支持持久化）</span></span><br><span class="line"> <span class="comment">//文件后缀名一定是properties</span></span><br><span class="line"> p.store(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;person.properties&quot;</span>),<span class="string">&quot;this is a girl....&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> cn.tedu.properties;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo2</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"> <span class="comment">//创建对象</span></span><br><span class="line"> Properties p=<span class="keyword">new</span> Properties();</span><br><span class="line"> <span class="comment">//加载文件信息</span></span><br><span class="line"> p.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;person.properties&quot;</span>));</span><br><span class="line"> <span class="comment">//通过键来获取值</span></span><br><span class="line"> System.out.println(p.getProperty(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"> <span class="comment">//列举数据---展示数据</span></span><br><span class="line"> p.list(System.out);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>线程</strong> </p><p>  进程：计算机上的应用拆分成的多个小任务（操作系统可以分配的最小单位）</p><p>  线程：进程可以拆分成的多个小任务（cpu可以处理的最小单位）</p><p>在<strong>某个时刻</strong>CPU的某个核中只能执行一个进程，这个进程中只能执行一个线程，<strong>CPU只能执行一个线程，cpu可以轮换线程执行</strong> </p><p><strong>多线程的好处</strong></p><p>  线程工作职责要么和cpu进行交互要么和硬件进行交互，当线程和硬件进行交互时cpu处于空闲状态，利用率较低，引入多线程可以去提高cpu的利用率</p><p><strong>实现多线程的方式</strong></p><ol><li><p>继承Thread类，重写run方法来描述线程任务信息，创建对象调用父类Thread类里start方法来开启线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.thread;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"> <span class="comment">//main方法的内容会放到底层主线程来执行</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建线程对象---创建描述线程任务信息类的对象</span></span><br><span class="line"> TDemo t=<span class="keyword">new</span> TDemo();</span><br><span class="line"> <span class="comment">//调用父类的方法来开启线程</span></span><br><span class="line"> <span class="comment">//线程对象不能回头执行</span></span><br><span class="line"> t.start();</span><br><span class="line"> <span class="comment">//主线程执行的内容</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line"> <span class="comment">//线程休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">5</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类---描述线程的任务信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TDemo</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"> <span class="comment">//重写的run方法就是线程的任务信息</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;run:&quot;</span>+i);</span><br><span class="line"> <span class="comment">//线程休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>实现Runnable接口 重写run方法来描述线程任务信息，由Runnable接口实现类的对象来构建thread对象来调用start方法来开启线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建描述线程信息类的对象</span></span><br><span class="line"> RDemo r=<span class="keyword">new</span> RDemo();<span class="comment">//Runnable接口的实现类对象</span></span><br><span class="line"> <span class="comment">//创建线程对象---Thread对象</span></span><br><span class="line"> Thread t=<span class="keyword">new</span> Thread(r);<span class="comment">//装饰者设计模式</span></span><br><span class="line"> <span class="comment">//调用start方法来开启线程</span></span><br><span class="line"> t.start();</span><br><span class="line"> <span class="comment">//主线程执行内容</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;main:&quot;</span>+i);</span><br><span class="line"> <span class="comment">//线程休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">5</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义类去描述线程的任务信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"> <span class="comment">//重写run方法指定线程的任务信息</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;run:&quot;</span>+i);</span><br><span class="line"> <span class="comment">//线程休眠</span></span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line"> Thread.sleep(<span class="number">10</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;io流&quot;&gt;&lt;a href=&quot;#io流&quot; class=&quot;headerlink&quot; title=&quot;io流&quot;&gt;&lt;/a&gt;io流&lt;/h1&gt;&lt;p&gt;根据传输方向和传输形式共同形成四大基本流（其他流都是从基本流衍生出来的）&lt;/p&gt;
&lt;p&gt;字符流（针对硬盘文件的输入和输出）&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="io流  线程" scheme="http://senye.ink/tags/io%E6%B5%81-%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>day22</title>
    <link href="http://senye.ink/2021/07/20/day22/"/>
    <id>http://senye.ink/2021/07/20/day22/</id>
    <published>2021-07-20T13:04:28.079Z</published>
    <updated>2021-07-20T13:06:17.933Z</updated>
    
    <content type="html"><![CDATA[<p>一套用于<strong>数据传输</strong>的机制</p><p>根据传输的方向（根据内存当做参照物）：输入流—从外部往内存来传输数据   输出流—从内存往外来传输数据  </p><p>根据数据表现形式：字节流—底层以字节流来传输数据  字符流—底层以字符来传输数据</p><p>四大基本流   对应的四个类都是抽象类</p><table><thead><tr><th></th><th>输出流</th><th>输入流</th></tr></thead><tbody><tr><td>字符流</td><td>字符输出流 Writer</td><td>字符输入流 Reader</td></tr><tr><td>字节流</td><td>字节输出流OutputStream</td><td>字节输入流 InputStream</td></tr></tbody></table><p>传输场景 （数据存放 、获取的位置） ：硬盘 、内存、网络、外设</p><p>硬盘 </p><p>   字符流</p><p>​      往一个txt文件中写入内容   文件   输出流   FileWeiter （文件字符输出流）</p><p>​     从一个TXT文件中读取内容  文件  输入流  FileReader（文件字符输入流）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个文件字符输入流对象</span></span><br><span class="line">        <span class="comment">//底层没有缓存区</span></span><br><span class="line">        FileReader reader=<span class="keyword">new</span> FileReader(<span class="string">&quot;D:\\as.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        <span class="comment">//read无参方法返回的是读取到的一个字符对应的编码值</span></span><br><span class="line"><span class="comment">/*        System.out.println(reader.read());</span></span><br><span class="line"><span class="comment">        System.out.println(reader.read());</span></span><br><span class="line"><span class="comment">        //读取结束的条件是-1</span></span><br><span class="line"><span class="comment">        System.out.println(reader.read());*/</span></span><br><span class="line">        <span class="comment">//通过循环来实现</span></span><br><span class="line">       <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((i=reader.read())!=-<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关流</span></span><br><span class="line">        reader.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  字节流</p><p>​       往一个TXT文件中写入内容  文件  输出流  FileOutputStream</p><p>​      往一个TXT文件中读取内容   文件  输入流  FileOutputStream</p><p>io流的异常捕获</p><ol><li><p>在try块外声明流对象并赋值为null，真正的初始化在try块里</p></li><li><p>保证流对象只有初始化成功才能进行正常的关流</p></li><li><p>无论关流成功与否 都要把流对象置为null 值 等待系统进行垃圾回收</p></li><li><p>close 关流中包含自动冲刷 如果关流失败发生在自动冲刷之前就有可能导致数据滞留在缓冲区 需要手动冲刷</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//1.声明一个成员变量----流对象 声明的流对象初始值为null</span></span><br><span class="line">      FileWriter writer=<span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//真正的初始化在try块里</span></span><br><span class="line">         writer=<span class="keyword">new</span> FileWriter(<span class="string">&quot;D:\\s.txt&quot;</span>);</span><br><span class="line">         <span class="comment">//传输数据</span></span><br><span class="line">          writer.write(<span class="string">&quot;你想屁吃&quot;</span>);</span><br><span class="line">          <span class="comment">//4.防止close出现异常在自动冲刷之前---手动冲刷</span></span><br><span class="line">          writer.flush();</span><br><span class="line">      &#125;<span class="keyword">catch</span> (IOException e )&#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//2.保证流对象初始化成功才能关流（流对象的值不为null）</span></span><br><span class="line">          <span class="keyword">if</span>(writer!=<span class="keyword">null</span>)&#123;</span><br><span class="line">              <span class="keyword">try</span>&#123;</span><br><span class="line">                  writer.close();</span><br><span class="line">              &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//3.无论close方法是否执行成功都需要流对象置为null</span></span><br><span class="line">                  writer=<span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一套用于&lt;strong&gt;数据传输&lt;/strong&gt;的机制&lt;/p&gt;
&lt;p&gt;根据传输的方向（根据内存当做参照物）：输入流—从外部往内存来传输数据   输出流—从内存往外来传输数据  &lt;/p&gt;
&lt;p&gt;根据数据表现形式：字节流—底层以字节流来传输数据  字符流—底层以字符来传输数据</summary>
      
    
    
    
    
    <category term="io流" scheme="http://senye.ink/tags/io%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>day21</title>
    <link href="http://senye.ink/2021/07/19/day21/"/>
    <id>http://senye.ink/2021/07/19/day21/</id>
    <published>2021-07-19T12:55:20.185Z</published>
    <updated>2021-07-19T12:56:46.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>参数化类型，jdk1.5新特性</p><p>现在常用的泛型写法：声明类&lt;引用类型&gt;名称=new 实际创建类&lt;&gt;();</p><p>泛型可以指定为任意引用类型，当指定位具体的类型是后续就只能操作对应类型的对象—泛型的擦除（编译时期）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;112&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;4242&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; list1=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list1.add(<span class="number">1</span>);</span><br><span class="line">        list1.add(<span class="number">2</span>);</span><br><span class="line">        List&lt;Character&gt; list2=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list2.add(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">        list2.add(<span class="string">&#x27;d&#x27;</span>);</span><br><span class="line">        m(list);<span class="comment">//调用方法</span></span><br><span class="line">        m(list1);</span><br><span class="line">        m(list2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">m</span><span class="params">(List&lt;? extends Object&gt; list )</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object l:list)&#123;</span><br><span class="line">            System.out.println(l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>泛型的上下限</strong>（不允许同时出现上下限）</p><? extends Number>? 代表可以接收的类型---可以接受Number类以及Number的子类上限<? extends 类、接口>---可以接受类、接口以及子类、子接口下限<? super 类 接口>----可以接受类 接口以及父类  父接口### 映射可以存储多个一对具有映射关系的数据的容器k代表键的泛型，v代表的是值的范围键可以得到对应值，键不能重复但是值可以重复，一个映射容器可以由多个键和多个值来组成 键和值可以一起操作称之为键值对 java 提供一个entry类代表键值对，创建这个类的对象就是得到一个具体的键值对 Map<String,Integer> map= new HasMap<>();底层根据键来确定值的位置 因为键是无序的，所以键值对所在的位置也是无序的并且不能保证键值对的顺序恒久不变键不能重复 如果键重复 值没有重复  会把新的键对象舍弃掉，保留下来值 并进行覆盖 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,String &gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">12</span>,<span class="string">&quot;ds&quot;</span>);</span><br><span class="line">        map.put(<span class="number">2</span>,<span class="string">&quot;s&quot;</span>);</span><br><span class="line">        map.put(<span class="number">122</span>,<span class="string">&quot;jks&quot;</span>);</span><br><span class="line">       <span class="comment">// map.clear();</span></span><br><span class="line">        <span class="comment">//System.out.println(map);</span></span><br><span class="line">        <span class="comment">//判断映射中是否包含指定的键</span></span><br><span class="line">        System.out.println(map.containsKey(<span class="number">12</span>));</span><br><span class="line">        <span class="comment">//判断映射中是否包含指定的值</span></span><br><span class="line">        System.out.println(map.containsValue(<span class="string">&quot;q&quot;</span>));</span><br><span class="line">        <span class="comment">//把映射的集合放到Set集合中</span></span><br><span class="line">        Set&lt;Map.Entry&lt;Integer,String&gt;&gt; s=map.entrySet();</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        System.out.println(map.get(<span class="number">12</span>));</span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        <span class="comment">//把映射中所有 的键存放到Set集合中</span></span><br><span class="line">        Set&lt;Integer&gt; se=map.keySet() ;</span><br><span class="line">        System.out.println(se);</span><br><span class="line">        map.remove(<span class="number">12</span>);</span><br><span class="line">        System.out.println(se);</span><br><span class="line">        <span class="comment">//返回映射过程中键值对的个数</span></span><br><span class="line">        System.out.println(map.size());</span><br><span class="line">        <span class="comment">//把映射中所有的值存放到Collection中</span></span><br><span class="line">        Collection&lt;String&gt; c = map.values();</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        <span class="comment">//底层是根据键来确定存储位置</span></span><br><span class="line">        <span class="comment">//因为键是无序的所以键值对所在的位置也是无序的</span></span><br><span class="line">        <span class="comment">//并且不能保证键值对的顺序恒久不变</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>### 遍历映射1. 返回映射中所有的键，再有键来获取对应的值   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历Set集合</span></span><br><span class="line">       Set&lt;Integer&gt; set=map.keySet();</span><br><span class="line">       <span class="keyword">for</span> (Integer i:set)&#123;</span><br><span class="line">           System.out.println(s+<span class="string">&quot;:&quot;</span>+map.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure>2. 返回映射中所有的键值对   Map是映射的顶级接口   实现类：HasMap，HashtableHashMap底层根据数组+链表来实现的数据存储通过键来确定键值对的存储位置键是无序的并且不能存储重复的键（如果遇到重复的键就会把新的键对象舍弃掉）键值对是无序的 不能存储重复键值对默认的初始容量是16，默认的加载因子为0.75，默认没错扩容是在原容量的基础上增加一倍**允许存储null和null值****可以指定默认的初始容量是在这个 2的n次方到2的n次方+1**异步式线程不安全的映射Hashtable 最早的映射类不允许存储null键和null值默认的初始容量为11，默认的加载因子为0.75，默认每次扩容是在原来的基础上增加一倍并+1、指定初始容量多少底层真是容量就是多少同步是线程安全的映射映射是不是集合？一定不是！### File类代表文件或者文件夹的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建代表文件类的对象</span></span><br><span class="line">        <span class="comment">//创建对象时只是把路径信息放到对象身上并不检测路径信息是否存在</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//新建文件</span></span><br><span class="line">        <span class="keyword">boolean</span> b = file.createNewFile();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//创建新的文件夹</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\a&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> c = file1.mkdirs();</span><br><span class="line">        System.out.println(b);</span><br><span class="line">        <span class="comment">//创建多级文件夹</span></span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;D:\\a\\b\\c&quot;</span>);</span><br><span class="line">        <span class="keyword">boolean</span> d = file2.mkdirs();</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//删除文件 无论是否有内容</span></span><br><span class="line">        <span class="comment">//只能删除没有内容的文件夹</span></span><br><span class="line">        <span class="comment">//不进回收站 永久删除</span></span><br><span class="line">        <span class="keyword">boolean</span> k = file.delete();</span><br><span class="line">        System.out.println(k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个代表文件类的对象</span></span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;D\\&quot;</span>);</span><br><span class="line">        <span class="comment">//把当前文件夹下所有的信息当作成file类的对象存储在数组中并进行返回</span></span><br><span class="line">        File[] fs=file.listFiles();</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="comment">/*for (File f:fs)&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(f);//每个数组元素代表一个file类的对象</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//判断file类的对象是否为文件夹</span></span><br><span class="line">        System.out.println(file.isDirectory());</span><br><span class="line">        <span class="comment">//判断file类的对象是否为文件</span></span><br><span class="line">        System.out.println(file.isFile());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//返回文件名称以及后缀</span></span><br><span class="line">        System.out.println(file.getName());</span><br><span class="line">        <span class="comment">//返回文件的当前文件夹的路径信息 getName+getParent 就是文件的总路径</span></span><br><span class="line">        System.out.println(file.getParent());</span><br><span class="line">        <span class="comment">//返回全路径信息</span></span><br><span class="line">        System.out.println(file.getPath());</span><br><span class="line">        <span class="comment">//返回上一次的修改时间</span></span><br><span class="line">        System.out.println(file.lastModified());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建代表文件类对象</span></span><br><span class="line">        File file=<span class="keyword">new</span> File(<span class="string">&quot;D:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//重命名 --- 剪切实现的</span></span><br><span class="line">        <span class="keyword">boolean</span> b =file.renameTo(<span class="keyword">new</span> File(<span class="string">&quot;D:\\b.txt&quot;</span>));</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></String,Integer>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h3&gt;&lt;p&gt;参数化类型，jdk1.5新特性&lt;/p&gt;
&lt;p&gt;现在常用的泛型写法：声明类&amp;lt;引用类型&amp;gt;名称=new 实际创建类&amp;lt;&amp;gt;()</summary>
      
    
    
    
    
    <category term="范型 映射 文件" scheme="http://senye.ink/tags/%E8%8C%83%E5%9E%8B-%E6%98%A0%E5%B0%84-%E6%96%87%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>day20</title>
    <link href="http://senye.ink/2021/07/16/day20/"/>
    <id>http://senye.ink/2021/07/16/day20/</id>
    <published>2021-07-16T14:34:36.410Z</published>
    <updated>2021-07-16T11:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合 Collection"></a>集合 Collection<E></E></h3><ol><li><p>概述、</p><p> 可以存储多个元素对象且长度可变的容器</p></li></ol><p>&lt;大写字母&gt;—-泛型，用于指定集合元素的类型，由于泛型的限定元素类型只能是引用数据类型</p><p>Collection<integer> c; —-因为有自动封箱的存在所以可以存储int类型的数据 集合中可以存储基本类型的数据</integer></p><p>Collection<String> c; c 的数据类型是引用类型，元素类型是String类型</String></p><p>int[] arr;//arr的数据类型是引用类型，元素类型是int</p><ol start="2"><li><p>Collection是集合的顶级接口</p><p>子窗口：List Set Queue</p><p><strong><em>ArrayList</em></strong></p><p>底层由数组实现，默认数组长度为10，内存连续，需要扩容，底层根据右移运算来进行扩容，扩容之后的新长度为原长度加上原长度的一半来实现ArrayList长度可变  增删效率较低 查询效率较高。 线程不安全的集合</p><p><strong><em>LinkedList(链表)</em></strong></p><p>底层通过节点 静态内部类的对象来实现数据存储，通过节点之间的地址值的指向来维系节点。底层内存不连续不需要扩容  查询效率低  增删效率较高   线程不安全的集合</p><p><strong><em>Vector</em></strong></p><p>最早的集合类</p><p>底层通过数组实现，默认初始长度为10，底层根据三目运算来进行扩容，如果不给定增量的值每次扩容是在原容量的基础上增加一倍，如果给定增量的值就在原容器的基础上增加增量的值</p><p>线程安全的集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;&gt;(<span class="number">10</span>,<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">21</span>;i++)&#123;</span><br><span class="line">            v.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看当前容量</span></span><br><span class="line">        System.out.println(v.capacity());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stack(栈结构)</p><p> 遵循后进先出的原则</p><p>栈顶元素：最后一个存放的元素</p><p>栈底元素：第一个存放的元素</p><p>入栈/压栈：往栈中存放元素</p><p>出栈/弹栈：从栈中获取元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        Stack&lt;String&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//入栈</span></span><br><span class="line">        stack.push(<span class="string">&quot;121&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;21&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;0121&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;1221&quot;</span>);</span><br><span class="line">        stack.push(<span class="string">&quot;12661&quot;</span>);</span><br><span class="line">        <span class="comment">//判断是否栈为空</span></span><br><span class="line">        System.out.println(stack.empty());</span><br><span class="line">        <span class="comment">//返回栈顶元素并且不删除元素</span></span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line">        <span class="comment">//返回栈顶元素并且删除元素</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line">        <span class="comment">//c从栈顶往栈底来查找元素位置</span></span><br><span class="line">        System.out.println(stack.search(<span class="number">21</span>));</span><br><span class="line">        <span class="comment">//保证接口的特点 存放数据有序</span></span><br><span class="line">        System.out.pritln(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>Set </p><p>无序 不能存储重复元素  不能通过下标来操作</p><p>实现类： HashSet LinkedHashSet Treeset</p><p><strong>HashSet</strong></p></li></ol><p>底层通过HashMap实现数据存储（数组+链表） </p><p>不能保证迭代顺序恒久不变 </p><p>初始容量为16，扩容是在原来的基础上增加一倍，提供默认的加载因子为0.75 </p><p>线程不安全集合 </p><p>如果加载因子越大，扩容的时机越晚，容易导致某个链表上的节点数过多查询效率降低</p><p>如果加载因子越小，扩容越频繁导致rehash越频繁，造成大量的空间在浪费降低内存使用率</p><p>从jdk1.8开始如果某个链表中的长度超过了8个就可以扭转成二叉树来表示，可以提升查询效率</p><p><strong>LinkedHashSet</strong></p><p>底层是由LinkedHashMap来实现的 </p><p>可以记录存储对象的位置来保证数据存放的顺序</p><p><strong>TreeSet</strong></p><p>可以对存储的内容进行默认的升序排序 </p><p>先保证类实现Comparable接口产生的对象以及重写compareTo方法来指定排序规则，这样才能进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package cn.tedu.collection.set;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line">public class TreeSetDemo &#123;</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line"> &#x2F;&#x2F;创建集合对象</span><br><span class="line"> &#x2F;&#x2F;把存储的内容进行排序---升序</span><br><span class="line"> &#x2F;* TreeSet&lt;String&gt; t&#x3D;new TreeSet&lt;&gt;();</span><br><span class="line"> &#x2F;&#x2F;添加元素</span><br><span class="line"> t.add(&quot;abc&quot;);</span><br><span class="line"> t.add(&quot;bc&quot;);</span><br><span class="line"> t.add(&quot;ab&quot;);</span><br><span class="line"> t.add(&quot;ac&quot;);</span><br><span class="line"> t.add(&quot;1abc&quot;);</span><br><span class="line"> t.add(&quot;a3bc&quot;);</span><br><span class="line"> System.out.println(t);*&#x2F;</span><br><span class="line"> &#x2F;&#x2F;创建集合的对象</span><br><span class="line"> TreeSet&lt;Hero&gt; t&#x3D;new TreeSet&lt;&gt;();</span><br><span class="line"> t.add(new Hero(&quot;张飞&quot;,28,59));</span><br><span class="line">  t.add(new Hero(&quot;关羽&quot;,29,94));</span><br><span class="line"> t.add(new Hero(&quot;刘备&quot;,35,120));</span><br><span class="line"> t.add(new Hero(&quot;诸葛亮&quot;,25,99));</span><br><span class="line"> t.add(new Hero(&quot;赵云&quot;,24,97));</span><br><span class="line"> &#x2F;&#x2F;</span><br><span class="line"> for(Hero h:t)&#123;</span><br><span class="line"> System.out.println(h);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Hero implements Comparable&lt;Hero&gt;&#123;</span><br><span class="line"> String name;</span><br><span class="line"> int age;</span><br><span class="line"> int score;&#x2F;&#x2F;代表分数</span><br><span class="line"> &#x2F;&#x2F;有参构造</span><br><span class="line"> public Hero(String name,int age,int score)&#123;</span><br><span class="line"> this.name&#x3D;name;</span><br><span class="line"> this.age&#x3D;age;</span><br><span class="line"> this.score&#x3D;score;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;重写toString方法</span><br><span class="line"> @Override</span><br><span class="line"> public String toString() &#123;</span><br><span class="line"> return &quot;Hero&#123;&quot; +</span><br><span class="line"> &quot;name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +</span><br><span class="line"> &quot;, age&#x3D;&quot; + age +</span><br><span class="line"> &quot;, score&#x3D;&quot; + score +</span><br><span class="line"> &#39;&#125;&#39;;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;重写方法---指定排序规则</span><br><span class="line"> @Override</span><br><span class="line"> public int compareTo(Hero o) &#123;</span><br><span class="line"> &#x2F;&#x2F;指定以分数来排序</span><br><span class="line"> &#x2F;&#x2F;如果返回值是正数表面前面对象大于后面的对象</span><br><span class="line"> &#x2F;&#x2F;如果返回值是负数表面前面对象小于后面的对象</span><br><span class="line"> &#x2F;&#x2F;如果返回值是0表面前面对象内容等于后面的对象内容</span><br><span class="line"> &#x2F;&#x2F;return this.score-o.score;&#x2F;&#x2F;升序</span><br><span class="line"> return o.score-this.score;&#x2F;&#x2F;降序</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Queue</strong>队列</p><p>遵循先进先出（FIFO）的原则</p><p> 队头元素：第一个存放的元素 </p><p>队尾元素：最后一个存放的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.collection.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建队列对象</span></span><br><span class="line"> Queue&lt;String&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"> <span class="comment">//获取队头元素并不删除</span></span><br><span class="line"> <span class="comment">//如果没有队头元素就会报错</span></span><br><span class="line"> <span class="comment">//System.out.println(queue.element());</span></span><br><span class="line"> <span class="comment">//获取队头元素并不删除</span></span><br><span class="line"> <span class="comment">//如果没有队头元素就会返回特殊值---null值</span></span><br><span class="line"> System.out.println(queue.peek());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>迭代器</strong></p><p>1.底层是通过指针的挪动来遍历数据 </p><p>2.在遍历过程中不能直接删除原集合中的元素，但是可通过迭代器提供的remove方法来改变标记值间接删除原集合元素 3.iterator方法定义在Iterable接口中，调用这个方法返回迭代器Iterator接口 </p><p>4.类实现Iterable接口产生的对象支持增强for循环—增强for循环底层根据迭代器来实现—增强for循环是jdk1.5新特性 </p><p>5.增强for循环（比普通for循环增强的点是无论数据是否有下标都可以进行遍历）</p><p> 6.Ierable是Collection的父接口，所有的Collection（集合）的实现类创建的对象都支持增强for循环（迭代遍历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.collection.list;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建集合对象</span></span><br><span class="line"> List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;ac&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;bc&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;1abc&quot;</span>);</span><br><span class="line"> <span class="comment">//调用iterator方法返回对应的迭代器Iterator</span></span><br><span class="line"> <span class="comment">//集合对象内容会返回到迭代器的身上</span></span><br><span class="line"> Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"> <span class="comment">//通过循环实现---while</span></span><br><span class="line"> <span class="keyword">while</span> (it.hasNext())&#123;<span class="comment">//判断下一位是否有元素</span></span><br><span class="line"> <span class="comment">//返回下一个元素</span></span><br><span class="line"> String s = it.next();</span><br><span class="line"> System.out.println(s);</span><br><span class="line"> <span class="comment">//调用的是迭代器提供的remove方法</span></span><br><span class="line"> <span class="comment">//会把对应的标记改成false，java会默认把标记对应的原集合的元素来进行删除</span></span><br><span class="line"> <span class="comment">//it.remove();</span></span><br><span class="line"> <span class="comment">//集合提供的remove方法</span></span><br><span class="line"> <span class="comment">//会把原集合的敏内容直接删除但是会导致标记对应不到对应的元素内容就报错了</span></span><br><span class="line"> <span class="comment">//list.remove(s);</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> System.out.println(list);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;集合-Collection&quot;&gt;&lt;a href=&quot;#集合-Collection&quot; class=&quot;headerlink&quot; title=&quot;集合 Collection&quot;&gt;&lt;/a&gt;集合 Collection&lt;E&gt;&lt;/E&gt;&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;概述、&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="集合 List 队列 迭代器" scheme="http://senye.ink/tags/%E9%9B%86%E5%90%88-List-%E9%98%9F%E5%88%97-%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>day19</title>
    <link href="http://senye.ink/2021/07/15/day19/"/>
    <id>http://senye.ink/2021/07/15/day19/</id>
    <published>2021-07-15T14:13:18.276Z</published>
    <updated>2021-07-15T14:14:02.285Z</updated>
    
    <content type="html"><![CDATA[<h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4><p>无论try是否出现异常，finally都肯定执行完</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyDemo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        m();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//System.out.println(&quot;try&quot;);</span></span><br><span class="line">            System.out.println(<span class="number">1</span> / <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catch&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="集合（Collection）"><a href="#集合（Collection）" class="headerlink" title="集合（Collection）"></a>集合（Collection<E>）</E></h4><p>概述：可以存储多个元素 且长度可变的容器</p><p>&lt;大写字母&gt;—-泛型，用于去指定集合元素的类型，由于泛型的限定元素类型只能是引用数据类型</p><p>Collection<Integer> c;—-因为有自动封箱的存在 所以可以存储int类型数据 集合中可以存储基本类型数据       </Integer></p><p>Collection<String>c; c的数据类型是引用类型，元素类型是String 类型</String></p><p>int[] arr;//arr的数据类型是引用类型，元素类型是int</p><h4 id="Collection是集合的顶级接口"><a href="#Collection是集合的顶级接口" class="headerlink" title="Collection是集合的顶级接口"></a>Collection是集合的顶级接口</h4><p>子接口：List 重点  Set 重点 Queue </p><p>List(列表) 三个特点</p><ol><li><p>有序 存放数据有序</p></li><li><p>重复 </p></li><li><p>通过下表来存放</p></li></ol><p>实现类：ArrayList  LinkedList  Vector  Stack</p><p>实现类也会拥有对应的子接口的特点</p><p>ArrayList </p><p>底层由数组实现，默认数组长度为10，底层是根据右移运算来进行扩容，扩容之后的新长度为原长度的一半来实现Array List长度可变    增删效率低 查询效率较高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.collection.list;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//创建集合对象</span></span><br><span class="line"> List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//接口支持向上造型，声明类是接口实际创建类是接口的实现类</span></span><br><span class="line"> <span class="comment">//往集合容器中添加元素（末尾添加）</span></span><br><span class="line"> list.add(<span class="string">&quot;and&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;ad&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;an&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;can&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;arf&quot;</span>);</span><br><span class="line"> list.add(<span class="string">&quot;can&quot;</span>);</span><br><span class="line"> list.add(<span class="keyword">null</span>);</span><br><span class="line"> <span class="comment">//插入</span></span><br><span class="line"> <span class="comment">//支持插入的最大下标---元素个数</span></span><br><span class="line"> <span class="comment">//list.add(5,&quot;123&quot;);</span></span><br><span class="line"> <span class="comment">//删除元素</span></span><br><span class="line"> <span class="comment">//根据下标来进行删除（下标从0开始）</span></span><br><span class="line"> <span class="comment">//最大支持的下标---元素个数-1</span></span><br><span class="line"> <span class="comment">//下标受元素个数的限制</span></span><br><span class="line"> <span class="comment">//list.remove(4);</span></span><br><span class="line"> <span class="comment">//根据元素内容来删除</span></span><br><span class="line"> <span class="comment">//如果指定的内容没有在集合中出现就不删除（不做任何操作）</span></span><br><span class="line"> <span class="comment">//list.remove(&quot;can&quot;);</span></span><br><span class="line"> <span class="comment">//清空集合</span></span><br><span class="line"> <span class="comment">//list.clear();</span></span><br><span class="line"> <span class="comment">//判断指定内容是否包含在集合中</span></span><br><span class="line"> <span class="comment">//System.out.println(list.contains(&quot;a1d&quot;));</span></span><br><span class="line"> <span class="comment">//根据指定下标来返回集合中元素</span></span><br><span class="line"> <span class="comment">//最大支持下标---元素个数-1</span></span><br><span class="line"> <span class="comment">//System.out.println(list.get(1));</span></span><br><span class="line"> <span class="comment">//返回指定内容在集合中第一次出现的下标值</span></span><br><span class="line"> <span class="comment">//如果指定内容没有在集合中出现则返回-1</span></span><br><span class="line"> <span class="comment">//System.out.println(list.indexOf(&quot;can1&quot;));</span></span><br><span class="line"> <span class="comment">//判断集合中是否有元素</span></span><br><span class="line"> <span class="comment">//System.out.println(list.isEmpty());</span></span><br><span class="line"> <span class="comment">//根据指定下标来替换成新的内容</span></span><br><span class="line"> <span class="comment">//最大支持下标---元素个数-1</span></span><br><span class="line"> <span class="comment">//list.set(1,&quot;123&quot;);</span></span><br><span class="line"> <span class="comment">//返回集合存储的元素个数</span></span><br><span class="line"> <span class="comment">//System.out.println(list.size());</span></span><br><span class="line">     </span><br><span class="line"> <span class="comment">//截取子列表（含头不含尾）</span></span><br><span class="line"> <span class="comment">//System.out.println(list.subList(1,4));</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">/* Object[] os = list.toArray();</span></span><br><span class="line"><span class="comment"> for(Object o:os)&#123;</span></span><br><span class="line"><span class="comment"> //数组元素类型转成String类型</span></span><br><span class="line"><span class="comment"> String s=(String)o;</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="comment">//在转成数组之前可以给定数组对象根据给定数组对象的元素类型就可以确定返回的数组的元素类型</span></span><br><span class="line"> <span class="comment">//如果给定的长度在小于等于元素个数以及大于等于0这个范围展示全部元素的内容，如果大于元素个数</span></span><br><span class="line">多余的就是<span class="keyword">null</span>值</span><br><span class="line"> <span class="comment">/*String[] ss = list.toArray(new String[0]);</span></span><br><span class="line"><span class="comment"> //</span></span><br><span class="line"><span class="comment"> System.out.println(Arrays.toString(ss));*/</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> System.out.println(list);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListText</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过数组实现ArrayList</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListArray</span></span>&#123;</span><br><span class="line"> <span class="comment">//定义数组存储元素</span></span><br><span class="line"> String[] data;</span><br><span class="line"> <span class="comment">//定义变量代表数组下标/代表元素个数</span></span><br><span class="line"> <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line"> <span class="comment">//无参构造---默认数组长度为10</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ListArray</span><span class="params">()</span></span>&#123;</span><br><span class="line"> data=<span class="keyword">new</span> String[<span class="number">10</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//有参构造---指定数组初始长度</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ListArray</span><span class="params">(<span class="keyword">int</span> initialCapcity)</span></span>&#123;</span><br><span class="line"> data=<span class="keyword">new</span> String[initialCapcity];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//数组扩容</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(data.length&lt;=<span class="number">1</span>)</span><br><span class="line"> data= Arrays.copyOf(data,data.length+<span class="number">1</span>);</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> data= Arrays.copyOf(data,data.length+(data.length&gt;&gt;<span class="number">1</span>));</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//下标越界方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isOut</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;=size)&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Index:&quot;</span>+index);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//添加元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//判断是否需要扩容</span></span><br><span class="line"> <span class="keyword">if</span>(size&gt;=data.length)&#123;</span><br><span class="line"> grow();</span><br><span class="line"> &#125;</span><br><span class="line"> data[size++]=str;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//插入元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index,String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//下标是否越界</span></span><br><span class="line"> <span class="keyword">if</span>(index&lt;<span class="number">0</span>||index&gt;size)&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Index:&quot;</span>+index);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//判断是否需要扩容</span></span><br><span class="line"> <span class="keyword">if</span>(size&gt;=data.length)&#123;</span><br><span class="line"> grow();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//依次把数组元素往后进行挪动</span></span><br><span class="line"> <span class="comment">/*for(int i=size-1;i&gt;=index;i--)&#123;</span></span><br><span class="line"><span class="comment"> //把前面元素赋值给后面相邻的元素</span></span><br><span class="line"><span class="comment"> data[i+1]=data[i];</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="comment">//数组复制实现元素往后挪动</span></span><br><span class="line"> System.arraycopy(data,index,data,index+<span class="number">1</span>,size-index);</span><br><span class="line"> <span class="comment">//把指定的新元素赋值到指定位置</span></span><br><span class="line"> data[index]=str;</span><br><span class="line"> <span class="comment">//添加元素需要计数</span></span><br><span class="line"> size++;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据下标来删除元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"> <span class="comment">//判断下标是否越界</span></span><br><span class="line"> isOut(index);</span><br><span class="line"> <span class="comment">//依次把数组元素往前挪动</span></span><br><span class="line"> <span class="comment">/* for(int i=index;i&lt;size-1;i++)&#123;</span></span><br><span class="line"><span class="comment"> //把后面元素赋值给前面相邻的元素</span></span><br><span class="line"><span class="comment"> data[i]=data[i+1];</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="comment">//数组复制实现元素往后挪动</span></span><br><span class="line"> System.arraycopy(data,index+<span class="number">1</span>,data,index,size-index-<span class="number">1</span>);</span><br><span class="line"> <span class="comment">//元素个数计数</span></span><br><span class="line"> size--;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据元素内容来删除</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//调用方法返回下标值</span></span><br><span class="line"> <span class="keyword">int</span> index = indexOf(str);</span><br><span class="line"> <span class="comment">//判断下标是否是-1</span></span><br><span class="line"> <span class="keyword">if</span>(index!=-<span class="number">1</span>)&#123;</span><br><span class="line"> remove(index);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据指定内容返回在集合中第一次出现的下标</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//通过循环来进行遍历(数组)</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;data.length;i++)&#123;</span><br><span class="line"> <span class="comment">//判断指定内容是否和数组元素相同</span></span><br><span class="line"> <span class="keyword">if</span>(str==data[i]||str!=<span class="keyword">null</span>&amp;&amp;str.equals(data[i]))&#123;</span><br><span class="line"> <span class="keyword">return</span> i;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//如果集合中没有出现指定内容返回-1</span></span><br><span class="line"> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//清空集合</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//之后会根据size范围来遍历元素</span></span><br><span class="line"> size=<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//判断集合是否包含指定内容</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//看indexOf方法是否返回一个不是-1的下标值</span></span><br><span class="line"> <span class="keyword">return</span> indexOf(str)!=-<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据指定下标来获取元素</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line"> <span class="comment">//下标是否越界</span></span><br><span class="line"> isOut(index);</span><br><span class="line"> <span class="comment">//根据下标获取数据对应的元素</span></span><br><span class="line"> <span class="keyword">return</span> data[index];</span><br><span class="line"> &#125;</span><br><span class="line">  <span class="comment">//判断集合是否为空</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> size==<span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//根据指定下标来替换成新的内容</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index,String str)</span></span>&#123;</span><br><span class="line"> <span class="comment">//下标越界问题</span></span><br><span class="line"> isOut(index);</span><br><span class="line"> <span class="comment">//替换---给指定数组元素来赋值</span></span><br><span class="line"> data[index]=str;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//返回集合元素个数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> size;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//截取子列表</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ListArray <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex,<span class="keyword">int</span> toIndex)</span></span>&#123;</span><br><span class="line"> <span class="comment">//下标越界问题</span></span><br><span class="line"> isOut(fromIndex);</span><br><span class="line"> isOut(toIndex);</span><br><span class="line"> <span class="comment">//判断两个下标的关系</span></span><br><span class="line"> <span class="keyword">if</span>(fromIndex&gt;toIndex)&#123;</span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;fromIndex:&quot;</span>+fromIndex+<span class="string">&quot;,toIndex:&quot;</span>+toIndex);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="keyword">int</span> count=toIndex-fromIndex;</span><br><span class="line"> <span class="comment">//创建新列表对象---子列表</span></span><br><span class="line"> <span class="comment">//调用有参构造指定数组初始长度（截取元素个数一致）</span></span><br><span class="line"> ListArray list=<span class="keyword">new</span> ListArray(count);</span><br><span class="line"> <span class="comment">//把原数组的内容复制到新列表对象的数组上</span></span><br><span class="line"> System.arraycopy(data,fromIndex,list.data,<span class="number">0</span>,count);</span><br><span class="line"> <span class="comment">//把复制的元素个数赋值给新列表对象的size属性</span></span><br><span class="line"> list.size=count;<span class="comment">//才能保证遍历到截取的元素</span></span><br><span class="line"> <span class="comment">//返回新列表对象---子列表</span></span><br><span class="line"> <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;finally块&quot;&gt;&lt;a href=&quot;#finally块&quot; class=&quot;headerlink&quot; title=&quot;finally块&quot;&gt;&lt;/a&gt;finally块&lt;/h4&gt;&lt;p&gt;无论try是否出现异常，finally都肯定执行完&lt;/p&gt;
&lt;figure class=&quot;h</summary>
      
    
    
    
    
    <category term="finally 集合" scheme="http://senye.ink/tags/finally-%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>day18</title>
    <link href="http://senye.ink/2021/07/14/day18/"/>
    <id>http://senye.ink/2021/07/14/day18/</id>
    <published>2021-07-14T14:35:20.116Z</published>
    <updated>2021-07-14T14:35:53.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h2><ol><li><p>BigDecimal类—支持小数的精确运算（前提是传入的是字符串）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以让计算过程提高80位来进行运算，最终还是64位来存储</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">strictfp</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//绝大部分小数二进制是无限位数</span></span><br><span class="line">       <span class="comment">/* double d=2.1-1.3;</span></span><br><span class="line"><span class="comment">        System.out.println(d);*/</span></span><br><span class="line">        <span class="comment">//支持小数的精确运算 保证传入的数据是字符串</span></span><br><span class="line">        BigDecimal bd1=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;2.1&quot;</span>);</span><br><span class="line">        BigDecimal bd2=<span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.2&quot;</span>);</span><br><span class="line">        <span class="comment">//需要用调用的方法来求差值</span></span><br><span class="line">        System.out.println(bd1.subtract(bd2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>BigInterger类—支持超大数运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//支持超大数运算</span></span><br><span class="line">        BigInteger bi=<span class="keyword">new</span> BigInteger(<span class="string">&quot;1321312&quot;</span>);</span><br><span class="line">        BigInteger bi2=<span class="keyword">new</span> BigInteger(<span class="string">&quot;46656554825745&quot;</span>);</span><br><span class="line">        <span class="comment">//通过调用方法让两个对象值相乘</span></span><br><span class="line">        System.out.println(bi.multiply(bi2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="时间日期类"><a href="#时间日期类" class="headerlink" title="时间日期类"></a>时间日期类</h3><p>Date 类 表示时间日期类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Date date=<span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="comment">//在指定内容上加上1900年1月</span></span><br><span class="line">        <span class="comment">//黑线--代表过时的，预示着将来某个新版本就会被剔除掉</span></span><br><span class="line">        Date date=<span class="keyword">new</span> Date(<span class="number">2008</span>-<span class="number">1900</span>,<span class="number">8</span>-<span class="number">1</span>,<span class="number">8</span>);</span><br><span class="line">        System.out.println(date); &#125;</span><br><span class="line"><span class="comment">//输出过时的时间 2008 8 8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SimpleDateFormat 类 –提供字符串和日期相互转换（parse()—把字符串转日期  format（）—把日期转成字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        <span class="comment">//日期和字符串相互转换</span></span><br><span class="line">        <span class="comment">//字符串转日期</span></span><br><span class="line">        String str = <span class="string">&quot;2012-12-12 12:12:12&quot;</span>;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        <span class="comment">//parseException---解析异常（没有指定格式解析）</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="comment">//通过对象调用方法把字符串转成日期</span></span><br><span class="line">        Date date = sdf.parse(str);</span><br><span class="line">        System.out.println(date);</span><br><span class="line">         SimpleDateFormat sdf1 =<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年-MM月-dd日 HH时:mm分:ss秒&quot;</span>);</span><br><span class="line">        String s=sdf1.format(date);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Calendar类 是抽象类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用静态方法返回抽象类的子类对象</span></span><br><span class="line">        Calendar c =Calendar.getInstance();<span class="comment">//new子类对象</span></span><br><span class="line">        <span class="comment">//给日历子类对象设置时间</span></span><br><span class="line">        c.setTime(<span class="keyword">new</span> Date(<span class="number">2008</span>-<span class="number">1900</span>,<span class="number">8</span>-<span class="number">1</span>,<span class="number">8</span>));</span><br><span class="line">        <span class="comment">//获取对象中包含属性信息</span></span><br><span class="line">        System.out.println(c.get(Calendar.DAY_OF_MONTH));<span class="comment">//当前月的哪一天</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>一套用于发现问题，反馈问题以及解决问题的机制、</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            String s =readFile(<span class="string">&quot;W://a.txt&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFoundException e )&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;问题解决了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;读取请完毕！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException</span>&#123;</span><br><span class="line">        <span class="comment">//根据指定的路径信息来找到文件</span></span><br><span class="line">        <span class="comment">//读取文件</span></span><br><span class="line">        <span class="comment">//发现问题然后反馈问题</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">&quot;路径有问题&quot;</span>);</span><br><span class="line">        <span class="comment">//return&quot;文件内&quot;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Throwable是异常的顶级父类</p><p>子类：</p><ol><li>Error ：合理的应用程序且不应该试图抓住的一类严重问题（用于调整我们的外部环境和需求来解决这个严重的问题）</li><li>Exception ： 合理的应用程序且可以解决也可以不解决    解决方式（抛出，捕获）、</li></ol><p>分类： 编译时异常 ：编译时期出错 一定要处理</p><p>除了RunTimeException 类以及子类之外所有的异常类都是编译时异常（包含Exception类）</p><p>ClonNotSupportException 克隆不支持异常</p><p>ParseException 解析异常</p><p>运行时异常： 编译时期没错 运行时期有错 可以处理 也可以不处理 RuntimoException类以及子类都是运行时异常</p><p>ArithemeticException 算数异常</p><p>ArrayIndexoutOfBounds 数组下标越界异常</p><p>NullPointer 空指针异常</p><p>ClassCastException 类型转换异常</p><p>NumberFormatException 数字格式异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ReadDemo3</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果是在main上抛出异常就是JVM来解决</span></span><br><span class="line">    <span class="comment">//public static void main(String[] args) throws FileNotExitsException&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//try块里存放的是有可能出现异常的代码</span></span><br><span class="line">            String str=readFile(<span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//方法上抛出了多少个编译时异常需要通过多少个catch来捕获</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotExitsException e) &#123;<span class="comment">//catch块会时时检测try块是否出现异常</span></span><br><span class="line">            <span class="comment">//如果try块里有异常发生catch块通过对应异常类类型来捕获对应的异常类对象</span></span><br><span class="line">            <span class="comment">//catch (FileNotExitsException e)声明一个对象用于来接收传递的异常类对象</span></span><br><span class="line">            <span class="comment">//=new FileNotExitsException(&quot;亲，盘符找不到&quot;);</span></span><br><span class="line">            <span class="comment">//e来接收传递的异常类对象</span></span><br><span class="line">            <span class="comment">//e指向异常类对象可以调用异常类方法返回问题的描述信息（返回的是私有化属性值）</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (FileNotFindException e)&#123;<span class="comment">//=new FileNotFindException(&quot;亲，您的文件类型不对&quot;);</span></span><br><span class="line">            <span class="comment">//子类对象调用父类方法返回父类的私有化属性值（问题描述信息）</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">            <span class="comment">//打印栈轨迹</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异常解决之后的代码正常执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果方法上抛出多个异常需要通过，来分隔</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotExitsException,FileNotFindException,NullPointerException</span>&#123;</span><br><span class="line">        <span class="comment">//读取文件内容</span></span><br><span class="line">        <span class="comment">//判断参数对象是否为null值</span></span><br><span class="line">        <span class="keyword">if</span>(path==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//发现问题，反馈问题</span></span><br><span class="line">           <span class="comment">// 运行时异常：编译时期没错运行时期有错 可以处理也可以不处理 RuntimeException类以及子类都是运行时异常</span></span><br><span class="line">             <span class="comment">//       分类</span></span><br><span class="line">            <span class="comment">//Exception---合理的应用程序且可以解决也可以不解决</span></span><br><span class="line">          </span><br><span class="line">            <span class="comment">//发现问题，反馈问题</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//运行时异常可以处理也可以不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断文件类型是否是txt文件</span></span><br><span class="line">        <span class="keyword">if</span>(!path.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;<span class="comment">//要把所有的不是txt文件的判断进来</span></span><br><span class="line">            <span class="comment">//文件类型不对</span></span><br><span class="line">            <span class="comment">//发现问题，反馈问题,添加问题描述信息（向上传递异常类对象）</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFindException(<span class="string">&quot;亲，您的文件类型不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断路径信息是否有问题</span></span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;W&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//盘符找不到</span></span><br><span class="line">            <span class="comment">//发现问题，需要反馈问题（往上传递异常类对象）</span></span><br><span class="line">            <span class="comment">//添加问题的描述信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotExitsException(<span class="string">&quot;亲，盘符找不到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;文件内容&quot;</span>;<span class="comment">//反馈问题之后的代码不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义异常类--编译时异常（如果继承编译时异常则是编译时自定义异常类，如果继承运行时异常则是运行时自定义异常类）</span></span><br><span class="line"><span class="comment">//普通类继承异常类就变成自定义异常类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileNotExitsException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//有参构造来进行属性初始化(可以给私有化属性来进行赋值)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileNotExitsException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message=message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取私有化属性的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileNotFindException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileNotFindException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="comment">//super语句---调用父类构造方法</span></span><br><span class="line">        <span class="comment">//调用父类构造方法给父类的私有化属性进行赋值</span></span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获方式</p><ol><li><p>想针对方法上抛出的所有异常进行单独的处理，提供对应多的catch来保证可以做单独处理—分别处理（捕获）</p></li><li><p>想对方法上抛出的异常统一做操作，提供一个catch指定声明类的类型是抛出所有的异常类的统一父类可以做同意操作—统一处理（捕获）</p></li><li><p>针对方法上抛出的异常类做统一处理但是不想指定统一父类可以给这些异常进行分组，每一组之间通过|来间隔可以做到每一个组可以做统一处理—分组处理（捕获—jdk1.7出现的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//组员类之间通过|来间隔，一组之间可以进行统一处理---分组捕获</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String str=readFile(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> ( FileNotExitsException|FileNotFindException|NullPointerException e) &#123;<span class="comment">//声明类用于指定来捕获的异常类对象的类</span></span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//异常解决之后的代码正常执行</span></span><br><span class="line">        System.out.println(<span class="string">&quot;读取完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个catch来对方法上抛出的异常做统一操作---统一处理（捕获）</span></span><br><span class="line">    <span class="comment">//声明类必须是统一父类</span></span><br><span class="line"> <span class="comment">/* public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment"> try &#123;</span></span><br><span class="line"><span class="comment"> String str=readFile(null);</span></span><br><span class="line"><span class="comment"> &#125; catch ( Exception e) &#123;//声明类用于指定来捕获的异常类对象的类</span></span><br><span class="line"><span class="comment">捕获的方式</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> &#125; catch ( Exception e) &#123;//声明类用于指定来捕获的异常类对象的类</span></span><br><span class="line"><span class="comment"> System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> //异常解决之后的代码正常执行</span></span><br><span class="line"><span class="comment"> System.out.println(&quot;读取完毕&quot;);</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">    <span class="comment">//针对每个抛出的异常提供对应的catch做单独处理---分别处理（捕获）</span></span><br><span class="line"> <span class="comment">/*public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment"> try &#123;</span></span><br><span class="line"><span class="comment"> String str=readFile(null);</span></span><br><span class="line"><span class="comment"> &#125; catch ( FileNotExitsException e) &#123;//声明类用于指定来捕获的异常类对象的类</span></span><br><span class="line"><span class="comment"> System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment"> &#125;catch (FileNotFindException e)&#123;</span></span><br><span class="line"><span class="comment"> System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment"> &#125;catch (NullPointerException e)&#123;</span></span><br><span class="line"><span class="comment"> //打印栈轨迹</span></span><br><span class="line"><span class="comment"> e.printStackTrace();</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> //异常解决之后的代码正常执行</span></span><br><span class="line"><span class="comment"> System.out.println(&quot;读取完毕&quot;);</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">    <span class="comment">//如果是在main上抛出异常就是JVM来解决</span></span><br><span class="line">    <span class="comment">//public static void main(String[] args) throws FileNotExitsException&#123;</span></span><br><span class="line">    <span class="comment">//如果多个catch的声明类具有继承关系需要先子后父（按照这个逻辑顺序来指定）</span></span><br><span class="line"> <span class="comment">/*public static void main(String[] args) &#123;</span></span><br><span class="line"><span class="comment"> try &#123;</span></span><br><span class="line"><span class="comment"> String str=readFile(null);</span></span><br><span class="line"><span class="comment"> &#125; catch ( FileNotExitsException e) &#123;//声明类用于指定来捕获的异常类对象的类</span></span><br><span class="line"><span class="comment"> System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment"> &#125;catch (FileNotFindException e)&#123;</span></span><br><span class="line"><span class="comment"> System.out.println(e.getMessage());</span></span><br><span class="line"><span class="comment"> &#125;catch (Exception e)&#123;</span></span><br><span class="line"><span class="comment"> //=new NullPointerException();</span></span><br><span class="line"><span class="comment"> //打印栈轨迹</span></span><br><span class="line"><span class="comment"> e.printStackTrace();</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> //异常解决之后的代码正常执行</span></span><br><span class="line"><span class="comment"> System.out.println(&quot;读取完毕&quot;);</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line">    <span class="comment">//如果方法上抛出多个异常需要通过，来分隔</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotExitsException,FileNotFindException,NullPointerException</span>&#123;</span><br><span class="line">        <span class="comment">//读取文件内容</span></span><br><span class="line">        <span class="comment">//判断参数对象是否为null值</span></span><br><span class="line">        <span class="keyword">if</span>(path==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//发现问题，反馈问题</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();<span class="comment">//运行时异常可以处理也可以不处理</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断文件类型是否是txt文件</span></span><br><span class="line">        <span class="keyword">if</span>(!path.endsWith(<span class="string">&quot;.txt&quot;</span>))&#123;<span class="comment">//要把所有的不是txt文件的判断进来</span></span><br><span class="line">            <span class="comment">//文件类型不对</span></span><br><span class="line">            <span class="comment">//发现问题，反馈问题,添加问题描述信息（向上传递异常类对象）</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFindException(<span class="string">&quot;亲，您的文件类型不对&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断路径信息是否有问题</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断路径信息是否有问题</span></span><br><span class="line">        <span class="keyword">if</span>(path.startsWith(<span class="string">&quot;W&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//盘符找不到</span></span><br><span class="line">            <span class="comment">//发现问题，需要反馈问题（往上传递异常类对象）</span></span><br><span class="line">            <span class="comment">//添加问题的描述信息</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotExitsException(<span class="string">&quot;亲，盘符找不到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;文件内容&quot;</span>;<span class="comment">//反馈问题之后的代码不能执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>方法重写原则</p><p>   子类重写方法不能抛出比父类更大范围的编译时异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.exception;</span><br><span class="line"><span class="keyword">import</span> java.io.EOFException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo4</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EDemo1</span></span>&#123;</span><br><span class="line"> <span class="comment">//方法的重载和抛出的异常没有关系</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span><span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EDemo2</span> <span class="keyword">extends</span> <span class="title">EDemo1</span></span>&#123;</span><br><span class="line"> <span class="comment">//子类的重写方法不能抛出比父类更大范围的编译时异常</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span><span class="keyword">throws</span> EOFException, FileNotFoundException,NullPointerException </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数学类&quot;&gt;&lt;a href=&quot;#数学类&quot; class=&quot;headerlink&quot; title=&quot;数学类&quot;&gt;&lt;/a&gt;数学类&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;BigDecimal类—支持小数的精确运算（前提是传入的是字符串）&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    
    <category term="重要方法 数学类 异常" scheme="http://senye.ink/tags/%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95-%E6%95%B0%E5%AD%A6%E7%B1%BB-%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>day17</title>
    <link href="http://senye.ink/2021/07/13/day17/"/>
    <id>http://senye.ink/2021/07/13/day17/</id>
    <published>2021-07-13T13:55:46.526Z</published>
    <updated>2021-07-13T13:56:32.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h2><ol><li><h5 id="split-："><a href="#split-：" class="headerlink" title="split()："></a>split()：</h5><p>根据填入的正则语法来匹配关键信息，把关键信息当作切割符来切割原串返回字符串数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.pattern;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;daa6s12as12da12dsa&quot;</span>;</span><br><span class="line">        <span class="comment">//根据正则匹配的信息作为切割符</span></span><br><span class="line">        <span class="comment">//切割符对字符串对象切割得到一个字符串数组</span></span><br><span class="line">        <span class="comment">//如果切割符出现在字符串的最后面直接切掉如果在最前面会出现切切出空串</span></span><br><span class="line">        <span class="comment">//如果切割符出现多次并且为之出现在最后面那么会被全部切掉</span></span><br><span class="line">        <span class="comment">//如果切割符出现多次并且位置是在中间有n 个切割符就切出n-1个空串</span></span><br><span class="line">        String[] ss = str.split(<span class="string">&quot;\\d&quot;</span>);</span><br><span class="line">        <span class="comment">//展示数组</span></span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h5 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h5><p>把指定内容替换为新的信息</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String str= <span class="string">&quot;dahfahfahlka&quot;</span>;</span><br><span class="line">        <span class="comment">//把指定内容替换为新的信息</span></span><br><span class="line">        System.out.println(str.replace(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;*&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li><h5 id="subString"><a href="#subString" class="headerlink" title="subString():"></a>subString():</h5><p>根据指定的下标来截取字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String  str=<span class="string">&quot;jashdkjashdkjahkjda&quot;</span>;</span><br><span class="line">    <span class="comment">//从指定下标开始截取子串</span></span><br><span class="line">        System.out.println(str.substring(<span class="number">3</span>,<span class="number">8</span>));</span><br><span class="line"><span class="comment">//包含起始下标 不包含结束下标---含头不含尾</span></span><br><span class="line">        <span class="comment">//结束下标减去起始下标就是截取的子串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li><h5 id="toLowerCase-toUpperCase"><a href="#toLowerCase-toUpperCase" class="headerlink" title="toLowerCase/toUpperCase:"></a>toLowerCase/toUpperCase:</h5><p>转小写、转大写</p></li><li><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString():"></a>toString():</h5><p>对Object类中的toString进行重写，操作的就是字符串对象的内容</p></li><li><h5 id="trim"><a href="#trim" class="headerlink" title="trim():"></a>trim():</h5><p>针对字符串前后出现的空格要去掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String str= <span class="string">&quot; agfksa\tjsaad &quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(str+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="comment">//把字符串中前后空格干掉--掐头去尾</span></span><br><span class="line">        System.out.println(str.trim()+<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="7"><li><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf():"></a>valueOf():</h5><p>可以支持吧任意类型的数据转换成字符串类型的数据（都是静态方法）</p><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3></li></ol></li></ol><p>为了提高操作基本数据类型的便捷性，java给每个基本数据类型提供了对应的类（包装类），为了创建对应类的对象就可以操作对应的功能，提高操作的基本数据类型的效率。</p></li></ol><p><strong>注意</strong></p><ol><li><p>除了int和  char对应的包装类其他的包装类都是基本数据类型首字母大写</p></li><li><p>由基本数据类型来构建包装类对象—封箱</p></li><li><p>基本数据类型数据直接赋值给包装类对象—自动封箱</p><p>底层实现由包装类调用对应的valueOf方法来返回对应的包装类对象</p><p>包装类对象直接赋值给基本数据类型的数据—自动拆箱</p><p>底层实现由包装类对象调用对应的xxxValue()来返回对应的基本数据类型</p></li><li><p>自动封箱、拆箱都是jdk1.5的新特性</p></li><li><p>包装类对象所有的哈希码值都是固定值</p></li><li><p>所有数值型包装类的父类都是Number类</p></li></ol><h4 id="数学类"><a href="#数学类" class="headerlink" title="数学类"></a>数学类</h4><p>Math</p><p>绝对值 Math.abs(-1.2)   向上取整 Math.ceil(1.00001)   向下取整Math.floor(3.9999999)   第一个参数当作底数第二个参数当作次幂 Math.poe(16.0,0.5)   随机数Math.random() 从0.0到1.0的随机小数 1.0取不到（底层是根据伪随机算法实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">charp[] cs=&#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;z&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;</span><br><span class="line">String str=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="comment">//每一次循环得到一个随机字符</span></span><br><span class="line">str+=cs[(<span class="keyword">int</span>)(Math.random()*<span class="number">6</span>)];<span class="comment">//随机字符 指定随机下标</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(str)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重要方法&quot;&gt;&lt;a href=&quot;#重要方法&quot; class=&quot;headerlink&quot; title=&quot;重要方法&quot;&gt;&lt;/a&gt;重要方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&quot;split-：&quot;&gt;&lt;a href=&quot;#split-：&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    
    <category term="重要方法 api" scheme="http://senye.ink/tags/%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95-api/"/>
    
  </entry>
  
  <entry>
    <title>day16</title>
    <link href="http://senye.ink/2021/07/13/day16/"/>
    <id>http://senye.ink/2021/07/13/day16/</id>
    <published>2021-07-13T13:55:46.401Z</published>
    <updated>2021-07-13T14:01:06.988Z</updated>
    
    <content type="html"><![CDATA[<p>编码–把文字转成数字的过程 过程的规则—码表</p><p>ASSCII（阿斯科码表  底层占用一个字节（0~127) —-ISO8859-1（西欧码表 底层占用一个字节）—GB2312（中文简体） BIG5（中文繁体）—GBK（国标码 底层占用两个字节）  —Unicode编码体系 </p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><ol><li><h5 id="compareTo-：根据字典来比较两个字符串对象的大小"><a href="#compareTo-：根据字典来比较两个字符串对象的大小" class="headerlink" title="compareTo()：根据字典来比较两个字符串对象的大小"></a>compareTo()：根据字典来比较两个字符串对象的大小</h5></li><li><h5 id="compareToIgnoreCase-：忽略大小写来进行字典比较"><a href="#compareToIgnoreCase-：忽略大小写来进行字典比较" class="headerlink" title="compareToIgnoreCase()：忽略大小写来进行字典比较"></a>compareToIgnoreCase()：忽略大小写来进行字典比较</h5><p>先把两个字符串对象的内容赋值给两个字符数组；对两个字符数组对应的位置的字符求差值；如果差值不为0则把当前差值当做结果值来返回；如果差值为0则挪动下标继续求对应位置字符的差值；如果每个位置的字符差值都为0直到其中一个字符遍历完，结果值就是两个字符数组长度的差值；如果差值为正数则表明前面的字符串对象内容大于后面的字符对象内容；如果差值为负数表明前面的字符串对象内容小于后面的字符对象内容；如果差值为0表明前面的字符串对象内容等于后面的字符对象内容；根据返回的结果值对字符串对象的内容进行字典排序 IgnoreCase忽略大小写进行字典比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">&quot;abcs&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;Abxs&quot;</span></span><br><span class="line">System.out.println(str1.compareTo(str2));</span><br><span class="line">System.out.println(str1.compareToIgnoreCase(str2));</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><h5 id="concat-把指定的字符串对象内容拼接到原字符串对象内容的末尾进行返回新的字符串对象；"><a href="#concat-把指定的字符串对象内容拼接到原字符串对象内容的末尾进行返回新的字符串对象；" class="headerlink" title="concat():把指定的字符串对象内容拼接到原字符串对象内容的末尾进行返回新的字符串对象；"></a>concat():把指定的字符串对象内容拼接到原字符串对象内容的末尾进行返回新的字符串对象；</h5><p>concat底层是通过新数组的扩容来实现内容的拼接；+和concat的区别：1. +底层是由StringBuilder来做拼接的，cancat底层是数组扩容实现拼接 2.+可以拼接任意类型的数据 但是cancat只能拼接字符串对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str.concat(<span class="string">&quot;def&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><h5 id="contains-判断指定的字符串对象内容是否是原串的字符串的子串（返回值是布尔值）"><a href="#contains-判断指定的字符串对象内容是否是原串的字符串的子串（返回值是布尔值）" class="headerlink" title="contains():判断指定的字符串对象内容是否是原串的字符串的子串（返回值是布尔值）"></a>contains():判断指定的字符串对象内容是否是原串的字符串的子串（返回值是布尔值）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;anjash&quot;</span>;</span><br><span class="line">System.out.println(str.contains(<span class="string">&quot;sasdasd&quot;</span>))</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><h5 id="startsWith-endWith-判断是否以子串来开头、结尾-文件名称后缀-身份证-火车（G-高铁-T-特快-Z-直达）车牌号-身份证号"><a href="#startsWith-endWith-判断是否以子串来开头、结尾-文件名称后缀-身份证-火车（G-高铁-T-特快-Z-直达）车牌号-身份证号" class="headerlink" title="startsWith()/endWith():判断是否以子串来开头、结尾//文件名称后缀 身份证 火车（G-高铁 T-特快 Z-直达）车牌号 身份证号"></a>startsWith()/endWith():判断是否以子串来开头、结尾//文件名称后缀 身份证 火车（G-高铁 T-特快 Z-直达）车牌号 身份证号</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;xxxxx.avi&quot;</span>;</span><br><span class="line">System.out.println(str.endWith(<span class="string">&quot;.avi&quot;</span>));</span><br><span class="line">System.out.println(str.startsWith(<span class="string">&quot;xxxavi&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><h5 id="equals-重写Object类里的方法，重写的功能是根据对象的地址值和对象的内容来进行比较"><a href="#equals-重写Object类里的方法，重写的功能是根据对象的地址值和对象的内容来进行比较" class="headerlink" title="equals():重写Object类里的方法，重写的功能是根据对象的地址值和对象的内容来进行比较"></a>equals():重写Object类里的方法，重写的功能是根据对象的地址值和对象的内容来进行比较</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">String str1=<span class="string">&quot;aba&quot;</span>;</span><br><span class="line">String str2=<span class="keyword">new</span> String(<span class="string">&quot;Abc&quot;</span>)</span><br><span class="line"><span class="comment">//instanceof关键字，左边填入的是对象右边填入的可以是父类，本类，子类</span></span><br><span class="line"><span class="comment">//判断对象和类的关系</span></span><br><span class="line"><span class="comment">//是对Object类里的equals方法进行重写，重写的效果是不仅比较地址值还比较对象内容是否完全一致</span></span><br><span class="line">System.out.println(str.equals(str2));</span><br><span class="line"><span class="comment">//忽略大小写进行比较--验证码</span></span><br><span class="line">System.out.println(str1.equalsIgnoreCase(str2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><h5 id="getBytes-把字符串对象内容转成对应的字节数组进行返回"><a href="#getBytes-把字符串对象内容转成对应的字节数组进行返回" class="headerlink" title="getBytes():把字符串对象内容转成对应的字节数组进行返回"></a>getBytes():把字符串对象内容转成对应的字节数组进行返回</h5></li><li><h5 id="new-String-byte-bs-int-length-char-charset-可以把字节数组部分内容转成对应的新的字符串对象进行返回"><a href="#new-String-byte-bs-int-length-char-charset-可以把字节数组部分内容转成对应的新的字符串对象进行返回" class="headerlink" title="new String(byte[] bs,int length,char charset):可以把字节数组部分内容转成对应的新的字符串对象进行返回"></a>new String(byte[] bs,int length,char charset):可以把字节数组部分内容转成对应的新的字符串对象进行返回</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.sound.midi.Soundbank;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JieMa</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        String str=<span class="string">&quot;abc拿来吧你&quot;</span>;</span><br><span class="line">        <span class="comment">//把字符串对象的内容转成对应的字节数组（如果不能指定码表就是系统默认平台代码---GBK</span></span><br><span class="line">        <span class="comment">//如果指定码表就按指定的码表来编码</span></span><br><span class="line">        <span class="comment">//文字转成数字---编码</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        <span class="comment">//把字节数组转换成新的字符串对象</span></span><br><span class="line">        <span class="comment">//数字转成文字---解码</span></span><br><span class="line">        <span class="comment">//乱码的问题就是由于编码和解码使用的码表不一致导致的</span></span><br><span class="line">        <span class="comment">//String s = new String(bytes,&quot;gbk&quot;);</span></span><br><span class="line">        <span class="comment">//把字节数组部分内容转成新的字符串对象</span></span><br><span class="line">        String s = <span class="keyword">new</span> String(bytes,<span class="number">0</span>,<span class="number">6</span>,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">        System.out.println(bytes.length);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><h5 id="hashcode-针对Object类里方法进行重写，重写功能是计算过程之和和字符串对象的内容有关系"><a href="#hashcode-针对Object类里方法进行重写，重写功能是计算过程之和和字符串对象的内容有关系" class="headerlink" title="hashcode():针对Object类里方法进行重写，重写功能是计算过程之和和字符串对象的内容有关系"></a>hashcode():针对Object类里方法进行重写，重写功能是计算过程之和和字符串对象的内容有关系</h5></li><li><h5 id="indexOf-返回子串第一次出现的下标-如果没有找到返回-1"><a href="#indexOf-返回子串第一次出现的下标-如果没有找到返回-1" class="headerlink" title="indexOf():返回子串第一次出现的下标 如果没有找到返回-1"></a>indexOf():返回子串第一次出现的下标 如果没有找到返回-1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">String str=<span class="string">&quot;sadjvbdjf&quot;</span>;</span><br><span class="line"><span class="comment">//返回指定内容(子串)第一次出现的下标值</span></span><br><span class="line"><span class="comment">//如果没有找到返回-1</span></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;dj&quot;</span>));</span><br><span class="line"><span class="comment">//可以指定起始下标来查找第一次出现的子串（包含指定的下标）</span></span><br><span class="line">System.out.println(str.indexOf(<span class="string">&quot;dj&quot;</span>,<span class="number">3</span>));</span><br><span class="line">    </span><br></pre></td></tr></table></figure></li></ol><ol start="11"><li><h5 id="intern-把指向堆中的引用转向到方法区中"><a href="#intern-把指向堆中的引用转向到方法区中" class="headerlink" title="intern():把指向堆中的引用转向到方法区中"></a>intern():把指向堆中的引用转向到方法区中</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line"> <span class="comment">/* String str1=&quot;abc&quot;;</span></span><br><span class="line"><span class="comment"> String str2=new String(&quot;abc&quot;);</span></span><br><span class="line"><span class="comment"> //指向堆中的引用转向到方法区中</span></span><br><span class="line"><span class="comment"> str2=str2.intern();</span></span><br><span class="line"><span class="comment"> //</span></span><br><span class="line"><span class="comment"> System.out.println(str1==str2);*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="12"><li><h5 id="isEmpty-判断字符串对象是否为空串"><a href="#isEmpty-判断字符串对象是否为空串" class="headerlink" title="isEmpty():判断字符串对象是否为空串"></a>isEmpty():判断字符串对象是否为空串</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空串---本身是对象但是对象内容为空</span></span><br><span class="line"> String str=<span class="string">&quot;&quot;</span>;<span class="comment">//空串</span></span><br><span class="line"> String str1=<span class="keyword">new</span> String(<span class="string">&quot;&quot;</span>);<span class="comment">//空串</span></span><br><span class="line"> String str2=<span class="keyword">new</span> String();<span class="comment">//空串</span></span><br><span class="line"> String str3=<span class="keyword">null</span>;<span class="comment">//null值---不指向任何内容区域</span></span><br><span class="line"> <span class="comment">//判断字符串对象是否是空串</span></span><br><span class="line"> System.out.println(str.isEmpty());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><ol start="13"><li><h5 id="mathches-根据填入的正则语法来匹配对应的字符串信息"><a href="#mathches-根据填入的正则语法来匹配对应的字符串信息" class="headerlink" title="mathches(): 根据填入的正则语法来匹配对应的字符串信息"></a>mathches(): 根据填入的正则语法来匹配对应的字符串信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternDemo1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> String str=<span class="string">&quot;9dss3485h78gv1&quot;</span>;</span><br><span class="line"> <span class="comment">//匹配内容为abc的字符串对象</span></span><br><span class="line"> <span class="comment">//System.out.println(&quot;abc&quot;.equals(str));</span></span><br><span class="line"><span class="number">13.</span>matches():根据填入的正则语法来匹配对应的字符串信息</span><br><span class="line"></span><br><span class="line"> <span class="comment">//System.out.println(&quot;abc&quot;.equals(str));</span></span><br><span class="line"> <span class="comment">//如果匹配的内容是一段固定内容，正则里可以填入固定内容</span></span><br><span class="line"> <span class="comment">//matches方法是来做具体的匹配，在方法里填入的正则内容是匹配条件</span></span><br><span class="line"> <span class="comment">//System.out.println(str.matches(&quot;abc&quot;));</span></span><br><span class="line"> <span class="comment">//匹配内容为数字（单个）的字符串对象</span></span><br><span class="line"> <span class="comment">// //d--字符串转义--/d--正则转义--[0-9]</span></span><br><span class="line"> <span class="comment">//System.out.println(str.matches(&quot;\\d&quot;));</span></span><br><span class="line"> <span class="comment">//匹配小写英文字母</span></span><br><span class="line"> <span class="comment">//[起始-结束]可以在起始和结束范围之内匹配一个字符</span></span><br><span class="line"> <span class="comment">//System.out.println(str.matches(&quot;[a-z]&quot;));</span></span><br><span class="line"> <span class="comment">//.---代表任意一个字符</span></span><br><span class="line"> <span class="comment">//*代表数量词，来修饰前面字符出现的个数</span></span><br><span class="line"> <span class="comment">//*代表前面的字符可以不出现、可以出现1次也开以出现多次</span></span><br><span class="line"> <span class="comment">//System.out.println(str.matches(&quot;.*&quot;));</span></span><br><span class="line"> <span class="comment">//匹配字符串中含有数字</span></span><br><span class="line"> System.out.println(str.matches(<span class="string">&quot;.*\\d.*&quot;</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="14"><li><h5 id="replaceAll（）：根据填入正则"><a href="#replaceAll（）：根据填入正则" class="headerlink" title="replaceAll（）：根据填入正则"></a>replaceAll（）：根据填入正则</h5></li></ol><p><strong>正则表达式</strong></p><p>语法：d–字符串转义–/d–正则转义–【0-9】</p><p>  针对<em>字符串的内容</em>进行匹配</p><p>匹配内容为“你码没了”的字符串；System.out.println(“你码没了”.equals(str)); 如果匹配的内容时一段固定内容，正则里可以填固定内容；matches方法是来做具体匹配的，在方法里填入的正则内容是匹配条件；System.out.println(str.equals(“你码没了”))</p><p>\d：表示一个十进制的数字 [0-9]<br>\D：表示非数字</p><p>\w：表示一个字 [0－9a-zA-Z_]<br>\W：表示除[0－9a-zA-Z_]之外的字符</p><p>\s：表示一个空白字符（空格，tab，换页符等）<br>\S：表示一个非空白字符</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;编码–把文字转成数字的过程 过程的规则—码表&lt;/p&gt;
&lt;p&gt;ASSCII（阿斯科码表  底层占用一个字节（0~127) —-ISO8859-1（西欧码表 底层占用一个字节）—GB2312（中文简体） BIG5（中文繁体）—GBK（国标码 底层占用两个字节）  —Unicod</summary>
      
    
    
    
    
    <category term="重要方法 api" scheme="http://senye.ink/tags/%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95-api/"/>
    
  </entry>
  
  <entry>
    <title>day15</title>
    <link href="http://senye.ink/2021/07/09/day15/"/>
    <id>http://senye.ink/2021/07/09/day15/</id>
    <published>2021-07-09T12:36:55.460Z</published>
    <updated>2021-07-09T12:38:09.686Z</updated>
    
    <content type="html"><![CDATA[<p>clone():把原对象的属性值复制到新对象中 并且返回到新对象</p><p>finalize()：通知系统进行垃圾回收</p><p>getClass（）：返回实际创建类的类型</p><p>hashcode():：返回对象的哈希码值</p><p>toString（）：返回对象拼接的地址值</p><h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><p>最终类 —没有子类</p><p>java中所有的字符串常量 都是String类的对象</p><p>String类对象的内容存储在底层的无法改变的字符数组中，String类创建</p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><p>1.charAt():根据指定的下标返回对应的字符</p><p>2.length()：返回字符串对象的长度</p><p>3.toCharArray():将字符串对象内容转成新的字符数组进行返回</p><p>4.new String(char[] cs,int offset,int count)—可以将字符数组的部分内容转成新的字符串对象来进行返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.string;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo2</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> String str = <span class="string">&quot;asjcvh&quot;</span>;</span><br><span class="line"> <span class="comment">//给定字符串的下标返回对应的字符</span></span><br><span class="line"> <span class="comment">//字符串的下标对应底层存储的字符数组的下标（从0开始）</span></span><br><span class="line"> <span class="comment">//System.out.println(str.charAt(3));</span></span><br><span class="line"> <span class="comment">//遍历字符串</span></span><br><span class="line"> <span class="comment">//字符串对象调用length()返回字符串的长度</span></span><br><span class="line"> <span class="comment">//数组对象调用length属性返回数组长度</span></span><br><span class="line"> <span class="comment">/* for(int i=0;i&lt;str.length();i++)&#123;</span></span><br><span class="line"><span class="comment"> System.out.println(str.charAt(i));</span></span><br><span class="line"><span class="comment"> &#125;*/</span></span><br><span class="line"> <span class="comment">//将字符串对象内容转成新的字符数组</span></span><br><span class="line"> <span class="comment">//Ctrl+Alt+v---把返回值直接展示</span></span><br><span class="line"> <span class="keyword">char</span>[] cs = str.toCharArray();</span><br><span class="line"> <span class="comment">//先把字符数组内容转成新的字符串对象</span></span><br><span class="line"> <span class="comment">//String s = new String(cs);</span></span><br><span class="line"> <span class="comment">//可以把字符数组的部分内容转成新的字符串对象</span></span><br><span class="line"> String s = <span class="keyword">new</span> String(cs, <span class="number">1</span>, <span class="number">4</span>);</span><br><span class="line"> <span class="comment">//展示数组内容</span></span><br><span class="line"> System.out.println(Arrays.toString(cs));</span><br><span class="line"> System.out.println(s);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>equals()</p><p>  1.根据对象地址值来比较两个对象是否相等</p><p>  2.想根据对象地址值和对象属性值综合判断两个对象是否相等需要重写equal方法（判断对象地址值是否相同  判断参数对象是否为null  判断两个对象的类型是否一致  判断对象的属性是否一致）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.object;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1=<span class="keyword">new</span> Person();</span><br><span class="line">        p1.name=<span class="keyword">null</span>;</span><br><span class="line">        p1.age=<span class="number">10</span>;</span><br><span class="line">        p1.gender=<span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">        Person p2=<span class="keyword">new</span> Person();</span><br><span class="line">        p2.name=<span class="keyword">null</span>;</span><br><span class="line">        p2.age=<span class="number">10</span>;</span><br><span class="line">        p2.gender=<span class="string">&#x27;女&#x27;</span>;</span><br><span class="line">        System.out.println(p1.equals(p2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> gender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getClass() != obj.getClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Person p = (Person) obj;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.age != p.age) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.gender != p.gender) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name == p.name || <span class="keyword">this</span>.name != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.name.equals(p.name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最终类–没有子类"><a href="#最终类–没有子类" class="headerlink" title="最终类–没有子类"></a>最终类–没有子类</h4><p>java中所有的字符串常量都是String类的对象</p><p> String类对象的内容存储在底层的无法改变的字符数组中，</p><p>String类创建出的对象值也就无法改变 java中所有的常量存储在方法区的运行时常量池（字符串常量存的是引用，其他的常量存储是值） 如果给定的字符串常量内容和之前的出现的内容一致，公用同一个方法区常量引用—共享</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.string;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo1</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//String str引用指向&quot;abc&quot;</span></span><br><span class="line"> <span class="comment">/* String str=&quot;abc&quot;;</span></span><br><span class="line"><span class="comment"> System.out.println(str);</span></span><br><span class="line"><span class="comment"> //改变了指向,String str引用指向&quot;def&quot;</span></span><br><span class="line"><span class="comment"> str=&quot;def&quot;;</span></span><br><span class="line"><span class="comment"> System.out.println(str);*/</span></span><br><span class="line"> <span class="comment">//s1指向方法区</span></span><br><span class="line"> String s1=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line"> <span class="comment">//s2指向堆</span></span><br><span class="line"> String s2=<span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>);</span><br><span class="line"> <span class="comment">//s3给定的字符串常量的内容和s1给定内容一致，所以公用一个方法区的常量引用，所以地址值一致</span></span><br><span class="line"> String s3=<span class="string">&quot;ab&quot;</span>;</span><br><span class="line"> <span class="comment">//如果参与运算的都是常量，那么在编译时期就可以进行优化直接进行运算把运算之后的结果来进行赋</span></span><br><span class="line">值</span><br><span class="line"> <span class="comment">//编译优化先计算---“a”+&quot;b&quot;进行拼接的结果是&quot;ab&quot;再把这个结果值赋值给s4</span></span><br><span class="line"> <span class="comment">//s4指向方法区（和s1指向一致）</span></span><br><span class="line"> String s4=<span class="string">&quot;a&quot;</span>+<span class="string">&quot;b&quot;</span>;</span><br><span class="line"> String s5=<span class="string">&quot;a&quot;</span>;</span><br><span class="line"> <span class="comment">//s5=s5+&quot;b&quot;;</span></span><br><span class="line"> <span class="comment">//String类的对象底层由不可改变的字符数组来存储所以对象的值不能改变---不能做拼接</span></span><br><span class="line"> <span class="comment">//String类借由别的类来做内容的拼接</span></span><br><span class="line"> <span class="comment">//底层实现---s5=new StringBuilder(&quot;a&quot;).append(&quot;b&quot;).toString();</span></span><br><span class="line"> <span class="comment">//toString方法底层是创建一个新的String类对象来返回</span></span><br><span class="line"> <span class="comment">//s5指向堆</span></span><br><span class="line"> s5+=<span class="string">&quot;b&quot;</span>;</span><br><span class="line"> <span class="comment">//s1和s2指向不同内存分区所以地址值不相同</span></span><br><span class="line"> System.out.println(s1==s2);<span class="comment">//false</span></span><br><span class="line"> System.out.println(s1==s3);<span class="comment">//true</span></span><br><span class="line"> System.out.println(s1==s4);<span class="comment">//true</span></span><br><span class="line"> System.out.println(s1==s5);<span class="comment">//false</span></span><br><span class="line"> <span class="comment">//s2指向堆，s5指向堆但是开辟两个不同的堆内存所以地址值不一样</span></span><br><span class="line"> System.out.println(s2==s5);<span class="comment">//false</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StringBulider和StringBuffer</p><p>StringBuffer : 从jdk1.0出现用于实现String类的内容的拼接，线程安全但是拼接效率较低。</p><p>StringBuilder：从jdk1.5开始出现用于实现String类内容的拼接，线程不安全但是拼接效率较高。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;clone():把原对象的属性值复制到新对象中 并且返回到新对象&lt;/p&gt;
&lt;p&gt;finalize()：通知系统进行垃圾回收&lt;/p&gt;
&lt;p&gt;getClass（）：返回实际创建类的类型&lt;/p&gt;
&lt;p&gt;hashcode():：返回对象的哈希码值&lt;/p&gt;
&lt;p&gt;toString（）</summary>
      
    
    
    
    
    <category term="String 方法 最终类" scheme="http://senye.ink/tags/String-%E6%96%B9%E6%B3%95-%E6%9C%80%E7%BB%88%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>day14</title>
    <link href="http://senye.ink/2021/07/08/day14/"/>
    <id>http://senye.ink/2021/07/08/day14/</id>
    <published>2021-07-08T14:05:32.478Z</published>
    <updated>2021-07-08T14:06:55.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p> <strong>基本语法</strong></p><p>跨平台—事先在操作系用上存放对应的jvm 讲java程序放到jvm中来运行，使得相同的java程序在不同的操作系统上得到的结果是一样的  （一次编译 到处运行）.java文件在jvm外部进行编译，把.class文件放入到jvm中来运行</p><p><strong>三大架构</strong></p><p>javase(基础)  javaee（企业）  javame</p><p>搭建语言环境</p><p>jre:java运行时环境 包含jvm和核心类库</p><p>jdk：开发时的工具包—开发环境和运行环境 包含jre+kit（工具包）</p><p><strong>编译和运行</strong></p><p>.java文件（源文件）—-编译—-.class文件（字节码文件)  编译时期（在检测java程序的语法问题）</p><p>.class文件（字节码文件） 可以 运行—结果  运行时期在检测java程序的执行逻辑</p><p>main方法—可以让类单独执行、所有java程序的入口、被jvm调用</p><p>.java文件可以定义多个类 每个类可以被编译生成对应的.class文件</p><p><strong>关键字</strong></p><p>在java中具有特殊功能的单词 53个关键字 全部都是小写 false true null 有值                                                                                                                    </p><p><strong>标识符</strong></p><p>可以自定义 一定范围之内的名称 组成范围： 各国常见文字 数字 特殊符号  </p><p>命名规则：不能出现关键字 不能以数字开头 在组成范围之内符合命名规则–合法  在合法的基础上可以遵守规范 </p><p>驼峰命名法 ：</p><p>类名、接口名 :XxxYyy</p><p>方法名 变量名：xxxYyy</p><p>常量名：XXX_YYY</p><p>包名（每级名称都是小写）</p><p>要做到见名知意</p><p>注释 ：在代码中用于解释说明的文字 单行注释 //  多行注释/* */  文档注释 </p><p>常量：程序运行过程中 值不发生改变</p><p>分类： 字面值常量 （整数 小数 字符 字符串 布尔 空）  自定义常量（用fianal修饰数据—最终值   final int a =1 ）</p><p>数据的表现形式（二进制 八进制 十进制 十六进制 进制之间可以转换）</p><p>有符号的数：java中所有数据都是以底层二进制数据的补码形式来表示( 数据的操作也是以二进制数据的补码形式来操作)   源码 反码 补码 </p><p>小数（十进制的小数转成二进制绝大部分是无限位数）</p><p>变量 ：程序运行过程中值可以发生改变  可以存储单个数据的容器  容器：变量 单个数据 所有数据类型和数组  多个数据  所有数据类型</p><p>数据类型 {基本数据类型{4类8种} 引用数据类型{数组 类 接口}}：限制数据的变化范围</p><p>byte—2<code>7~2</code>7-1(-128—-127)</p><p>short—2<code>15 ~ 2</code>15-z(-12==23768~23767)</p><p>int—  -2<code>31~2</code>31</p><p>long—  -2<code>63~2</code>63-1</p><p>char–0~65535</p><p>编码—把文字转成数字的过程 转换的规则—码表</p><p>转义字符—‘\t’  引用数据类型（数组 接口 类）</p><p>类型的定义和转换 </p><p> 数据类型  变量名 ==初始值；</p><p>数据类型 变量名；声明</p><p>变量应=初始值</p><p>变量是在哪定义在哪使用</p><p>类型转换（1.类型提升 默认从小到大 2.强制类型转换）</p><p><strong>运算符</strong></p><p>算数运算符</p><p>+（加法 字符串连接符）（整数不能除0 小数可以）%（取余符号的左边的正负决定了结果的正负）++ – （如果在操作数之前先自加再赋值  如果在操作数之后 先赋值 再自加）</p><p>赋值运算符（扩展赋值运算符底层默认有强制类型转换）</p><p>比较运算符（结果一定是布尔值）</p><p>逻辑运算符（&amp;&amp; || —-都具有短路效果）</p><p>位运算符 针对二进制数据的补码形式来做运算符 &amp;（任意整数&amp;1来判断是否为奇数还是偶数 | 任意整数 |0还是本身 ^扩展规律</p><p>移位（左移 右移 无符号右移）</p><p>三目运算符</p><p>格式—布尔表达式？表达式值1：表达式值2； 结果一定是个值</p><p>优先级都可以通过（）来解决</p><p>流程控制语句</p><p>顺序结构</p><p>选择结构（做判断 提供选项来做判断）</p><p>if语句（三种格式对应三种选择场景） 根据范围来选择</p><p>switch语句（根据值来选择）</p><p>循环结构（解决重复执行的问题）</p><p>for循环 while 循环 dowhile循环  for循环和while循环的执行流程一致 如果循环范围确定 推荐for 如果不确定 推荐while循环</p><p>dowhile循环最少执行一次</p><p>continue 在循环中跳过当次循环</p><p>return 在方法中返回值 结束方法</p><p>break 在switch中结束语句 在循环中结束循环</p><p><strong>数组</strong></p><p>可以存储对个相同数据类型的元素  的容器（支持所有的数据类型）</p><p>定义格式</p><p>数据类型 数组 数组名=new 数据类型【数组长度】；//指定数组长度</p><p>数据类型 数组名 =new 数据类型【】{值1，值2}；//指定数组元素值也就把长度确定了</p><p>数据类型 数组名={值1，值2，…..、}；//指定数组元素值也就把长度确定了</p><p>数组名【编号】—-唯一确定 的数组元素</p><p>java内存分区</p><p>栈：存储的是变量 （暂且）—java的执行过程（所有的方法加载到栈中执行）  内容使用完毕立即清除 </p><p>堆：存储的是对象 对象使用完毕等到某个时刻来回收</p><p>方法区: 存储类的信息</p><p>本地方法栈：（本地 操作系统 方法）</p><p>寄存器（pc计数器）： 表示代码执行的指令</p><p>系统默认初始值（堆里）—（byte short char int–0)  ( char—-‘\0000’  )   (long—OL)  (float—0.0F)  (double–0.0)  (boolean—false)   引用数据类型 –null</p><p>应用</p><p>遍历（普通for循环  增强for循环：把数组元素拷贝给新变量 把结果拼接成一个字符串返回 </p><p>最值  （根据参照物来比较最大值、最小值）</p><p>查找   （有序 无序)  有序 二分根据二分算法来实现 缺点 ：无序 查找数在最前面</p><p>排序（排序算法—冒泡 （相邻两个元素进行比较  一轮比完得到一个最大值）选择（ 选择一个定点元素和后续其他元素进行比较一轮比完 得到一个最小值）） Arrays.sort（—-底层提供了很多排序算法）</p><p>扩容(通过原数组和新数组之间的复制实现扩容 两种方式来实现方式适用于灵活复制元素，第二种适用于从头复制 书写方便)</p><p><strong>二维数组</strong> </p><p> 存储元素是一位数组的数组</p><p>定义格式（1.指定二维数组长度以及每一个一位数组的长度 2.指定二维数组长度就是在声明一维数组 3.指定元素值来确定二维数组的长度）</p><p>方法</p><p>把重复且有效的代码抽象形式</p><p>格式</p><p>修饰符 方法返回值类型 方法名 （参数列表）{</p><p>方法体；</p><p>return 返回值；</p><p>}</p><p>java中的方法是根据方法签名来唯一确定</p><p>方法必须被调用才执行 （方法不主动执行）</p><p>抽取方法—-方法返回值类型 参数列表</p><p><strong>重载</strong>  </p><p> 在一个类中 方法名一致 参数；列表不一致 （只和方法名 和参数列表有关系）    </p><p><strong>传值</strong></p><p>实参是基本数据类型 传递的是值的拷贝 </p><p>实参是引用数据类型 传递的是地址值的拷贝</p><p>根据拷贝的地址值找到原堆内存就会有影响</p><p>根据拷贝的地址值没有找到对应的原堆内存就不会有影响</p><p><strong>递归</strong></p><p>执行方法过程中 再次调用本方法</p><p>递归次数过多 有可能会造成栈溢出错误</p><h4 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h4><p>面向过程：关注的是代码的实现细节</p><p>面向对象：先把代码实现细节整合到对象中，只要找到对象就能拥有对象的功能</p><p>面向对象基于面向过程</p><p>类与对象的关系</p><p>类是对象的概括 对象是对类的具体实现</p><p>类是描述信息的 描述的信息就是对象即将拥有的特征和行为</p><p>构造方法 </p><p>构建对象</p><p>属性初始化</p><p>支持重载 </p><p>类中至少含有一个构造方法</p><p><strong>this</strong></p><p>目的：属性初始化 参与类的信息和描述 可以让类中的属性和成员方法参与进来</p><p>功能：代表当前类的对象</p><p>this语句：—在本体的构造方法调用其他构造方法</p><p>构造代码块</p><p>无论调用哪个构造方法都要先执行构造代码块的内容</p><p>局部代码块</p><p>控制变量的生命周期</p><p>局部变量和成员变量</p><p>成员变量和成员方法 不包括构造方法 都是参与描述类的信息</p><p>定义位置</p><p>适用范围</p><p>内存分区</p><p>生命周期 0</p><p><strong>三大特征</strong></p><p>封装继承多态</p><p>封装：是为了以后更好的维护代码</p><p>方法：属性私有化提供公共的访问方式来做取值和赋值</p><p>继承</p><p>多个类出现重复内容 把重复内容拿到新的类中，让原来的类和新的类通过extends关键字产生继承关系，原来的类称之为子类，新的类称之为父类，子类只能继承父类的部分信息（私有化信息以及构造方法和构造代码块都不能继承）</p><p>java中类与类之间支持单继承（类只能有一个父类  一个父类可以有多个子类）</p><p>重写 </p><p>父子类出现方法签名一致的方法 </p><p>遵守重写原则（两等 两小 一大）</p><p>方法签名（是重写的前提）</p><p>如果父类 的方法返回值类型是基本数据类型或者是void那么子类的返回值方法要和父类的一致</p><p>子类的访问权限修饰符 要么和父类一致 要么比父类的范围要大</p><p>访问权限修饰符 （由定义信息的位置和操作信息的位置   控制可以在那些位置关系下操作定义的信息 ）</p><p>super </p><p>代表父类的对象 可以去调用父类 的信息</p><p>super 语句—在子类的构造方法中去调用父类的构造方法 保证每个子类的构造方法都可以调用到父类构造方法 父类对象优先于子类对象先出现  父子类对象信息的执行顺序（父类构造代码块-父类构造方法-子类构造代码块-子类构造方法）</p><p>多态</p><p>程序运行过程中可以展现的多种形态</p><p>编译时多态  编译时期绑定代码</p><p>方法重载       </p><p>运行时多态  运行时期绑定代码  重写   </p><p>静态变量</p><p>类存放在方法区的静态常量池里，静态变量存储在方法区静态常量池的静态区  可以通过类名.形式来调用也可以通过对象调用</p><p>静态变量被所有的对象共享</p><p>静态方法</p><p>类存放在方发区的静态常量池里，静态方法存储在方法区静态常量池的静态区   静态方法被调用加载到栈中执行  可以重载不能重写   静态信息不能直接访问非静态信息，静态信息可以直接访问静态信息，非静态信息可以直接访问静态信息以及非静态信息</p><p>静态代码块</p><p>预先加载资源以及静态属性初始化</p><p>随着类的加载而加载只加载一次</p><p>所有静态信息都只加载一次</p><p>父子类执行顺序（父类静态信息-子类静态信息–父类构造代码块 成员变量 –父类构造方法–子类（构造代码块，成员变量）-子类构造方法—先是类级别再试对象级别，无论是哪个级别顺序都是先父后子</p><p><strong>final</strong></p><p>修饰符，数据（如果是基本数据类型值不变，如果是引用类型是地址值不改变；如果是成员变量要求在创建对象之前给值，如果是静态常量要求在类加载完成之前给值—自定义变量</p><p>方法（可以重载不能重写），类（不能被继承）、</p><p><strong>abstract</strong></p><p>如果每个子类都对父类中某个方法进行不同程度的重写，某个方法的方法体没有实际意义可以把方法体去掉加上abstract变成 抽象方法，抽象方法所在的类是抽象类。 抽象方法要被重写 抽象类没有对象 抽象类的目的延展类的继承结构</p><p>接口</p><p>抽象类中的方法都是抽象方法可以变成接口</p><p> 接口不是类 类和接口的关系只能是实现（支持多实现），接口与接口支持多继承—目的是为了给实现类丰富更多的功能 </p><p>接口没有对象</p><p> 接口可以定义属性和抽象方法，属性默认被public static final共同修饰，抽象方法被public abstract来修饰 接口声明的对象可以在编译时期接收任意类型对象的赋值</p><p> 接口目的是为了注入更多的特性（功能）</p><p> 接口和抽象类的比较</p><p>优点：约束 模板</p><p><strong>内部类</strong></p><p>方法内部类</p><p>方法内定义类</p><p>不能访问权限修饰符修饰</p><p>可以获取本方法中常量信息</p><p>创建对象只能在本方法中</p><p><strong>成员内部类</strong></p><p>创建对象（由外部类对象调用内部类对象—要创建两个对象）</p><p><strong>静态内部类</strong></p><p>可以定义所有的信息</p><p>只能获取外部类的静态信息</p><p>创建对象</p><p><strong>匿名内部类</strong></p><p>可以默认继承类/实现接口，重写抽象方法 常用于方法形参类型是抽象类或者是接口的参数传递</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;复习&quot;&gt;&lt;a href=&quot;#复习&quot; class=&quot;headerlink&quot; title=&quot;复习&quot;&gt;&lt;/a&gt;复习&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;基本语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;跨平台—事先在操作系用上存放对应的jvm 讲java程序放到jvm中来运行，使得</summary>
      
    
    
    
    
    <category term="综合复习以上所学" scheme="http://senye.ink/tags/%E7%BB%BC%E5%90%88%E5%A4%8D%E4%B9%A0%E4%BB%A5%E4%B8%8A%E6%89%80%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>day13</title>
    <link href="http://senye.ink/2021/07/07/day13/"/>
    <id>http://senye.ink/2021/07/07/day13/</id>
    <published>2021-07-07T13:24:01.170Z</published>
    <updated>2021-07-07T13:24:44.778Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>类里定义类 ：匿名内部类</p><h4 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h4><p>栈：使用完内容 立即清除（不会产生垃圾）</p><p>方法区：存储类的信息（有垃圾但是很少）</p><p>堆：使用完对象 等到某个时刻才进行回收 （垃圾回收的主要针对内存区域）</p><p>堆分为新生代和老生代，新生代分为伊甸园区和幸存区。每次创建的新对象先存储在伊甸园区，系统针对这个区域进行一次扫描，如果发现新对象没有在使用就通知系统进行垃圾回收，如果新对象还在使用就新对象挪动到幸存区，系统针对幸存区这个区域进行多次扫描，如果发现对象没有在使用就通知系统进行垃圾回收，如果发生对象仍然还在使用就把对象挪动到老生代。系统针对老生代这个区域进行扫描，如果发现对象没有在使用通知系统进行垃圾回收，如果发现对象还在使用就是存储在老生代。</p><h4 id="·包"><a href="#·包" class="headerlink" title="·包"></a>·包</h4><p>区分同名类</p><p>用法：1.声明包 package 表明类的的位置，要在代码的首行，只能出现一个 ;2. import 导包 使用的类和当前类不在一个包下（不在代码首行 可以出现多个）3.* 代表通配符可以匹配到当前级别所有的类或者接口</p><p>提供的包</p><p>java : java原生包 </p><p>lang包：提供的是核心类库，随着程序的启动而加载，使用时不需要导包 ；</p><p>util 包 ：操作；类和对象的工具；</p><p>applet awt 包；</p><p>beans包：框架 ；</p><p>io包：数据传输；</p><p>math包：提供了简单的数学运算；</p><p>net包：网络传输 </p><p>nio包：高并发   2008  8  8  奥运会 网站崩了</p><p>security包：安全</p><p>sql包：操作sql语句的</p><p>time包：代表时间和日期</p><p>javax：java的扩展包</p><p>org  ：第三方厂商提供的包  Apache（民间组织） (hadoop) </p><h4 id><a href="#" class="headerlink" title></a></h4><p>API(appication Programing Interfaces)—应用程序接口（提供了一系列的类或者接口）api中所有的方法要么被</p><p>Object类是java中所有类的父类，java中所有的类默认继承object类。 </p><p>重要方法</p><p>1.clone() 把原对象中属性值拷贝到新对象中并且返回新对象类需要实现cloneable接口产生的对象才支持克隆</p><ol start="2"><li>finalize（）通知系统进行垃圾回收</li><li>getClass() 返回object的实际创建类型（本质是返回的是对象的类型—包名+类名）</li><li>hashcode（）返回对象的哈希码值，不同对象的哈希码值不一样 哈希码特点（取值范围广。散列分布—唯一的代表内存地址值）</li><li>toString() object类里的toStringa方法拼接对象地址值来返回 希望操作对象看到的是对象属性值而不是地址值需要重写object类里的toString方法以后定义类需要重写toString方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部类&lt;/h4&gt;&lt;p&gt;类里定义类 ：匿名内部类&lt;/p&gt;
&lt;h4 id=&quot;垃圾回收机制&quot;&gt;&lt;a href=&quot;#垃圾回收机制&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="内部类 垃圾返回机制 包" scheme="http://senye.ink/tags/%E5%86%85%E9%83%A8%E7%B1%BB-%E5%9E%83%E5%9C%BE%E8%BF%94%E5%9B%9E%E6%9C%BA%E5%88%B6-%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>day12</title>
    <link href="http://senye.ink/2021/07/06/day12/"/>
    <id>http://senye.ink/2021/07/06/day12/</id>
    <published>2021-07-06T14:02:44.132Z</published>
    <updated>2021-07-06T14:10:03.258Z</updated>
    
    <content type="html"><![CDATA[<p><strong>final(最终)</strong></p><p>关键字，修饰符     数据方法和类</p><p>最终值：final修饰的数据</p><p>1.如果是基本数据类型那么值不能改变，如果是引用数据类型那么地址值不能改变</p><p>2.如果final修饰的是成员变量要求在创建对象完成之前进行初始化，如果修饰的静态变量要求在类加载完成之前进行初始化</p><p>最终方法：可以重载但是不能重写</p><p>最终类：不能被别的类继承但是可以继承别的类</p><p><strong>abstract抽象</strong>、</p><p>关键字，修饰符 方法，类</p><p>多个子类都对父类中的某个方法进行了不同程度的重写，父类的某个方法的方法体内书写任何内容都没有意义所以可以把某个方法中方法体去掉并且加上abstract关键字来修饰就变成了抽象方法。抽象方法一定要被重写，普通类中出现了抽象方法那么要把普通类变成抽象类。普通继承了抽象类需要去重写抽象类中所有的抽象方法，如果不想重写所有的抽象方法可以把普通类变成抽象类</p><p>注意：1.抽下类中一定含有抽象方法？ 不一定</p><p>2.抽象类中可以定义属性和方法？可以</p><p>3.抽象类中可以定义构造方法？ 可以</p><p>4.抽象类可以创建对象？不能 底层创建对象是有其他编程语言来完成的 java获取不到，认为抽象类没有对象</p><p>5.抽象方法可以被private/static/final分别修饰？不能 如果加上修饰就不能被重写</p><p>6.抽象方法可以重载？可以 方法的重载只和方法名和参数列表有挂你先，与其他的修饰符和返回值都没有关系</p><p>7.抽象类可以被final修饰？final修饰的类是最终类，不能被继承 如果抽象类没有继承就不能重写抽象方法</p><p>8.抽象类的宗旨是为了延展类的继承结构，完善类与类的继承关系</p><p><strong>接口</strong> interface 本质不是类</p><p>1.当抽象类中所有的方法都是抽象方法可以把抽象类通过interface关键字变成接口</p><p><code>implements</code> —–实现 让类和接口之间产生实现关系</p><p>2.普通类实现一个接口，需要重写接口中所有的抽象方法</p><p>3.如果不想重写所有的抽象方法可以把当前类变成抽象类即可</p><p>4.支持多实现（一个类可以实现多个接口）</p><p>5.接口与接口之间多继承 类与接口之间多实现是为了丰富实现类的功能（更多的重写抽象方法）</p><p>注意：a.接口可以定义构造方法？不可以</p><p>b.接口可以创建对象吗？没有</p><p>c.接口里面的方法都是抽象方法？是的</p><p>d声明的接口在编译时期可以接受任意类型对象的赋值，但是在运行时期会检测是否实现关系</p><p>e.类里面可以定义属性方法？属性默认被public static final 共同修饰，抽象方法默认被public abstract共同修饰</p><p>f.接口和抽象类的区别：1.抽象类支持单继承，接口支持多继承，接口和实现类支持多实现 2.抽象类可以定义构造方法，接口不能定义构造方法 3.接口中的属性默认被public static final共同修饰 抽象方法默认被public abstract共同修饰4.抽象类中可以不是抽象方法，接口中都是抽象方法 5.抽象类是为了延展类的继承结构，接口是为了注入更多的特性</p><p>优点：模板 约束</p><p><strong>内部类</strong></p><p>类里再定义类：</p><p>方法内部类：在方法内定义类；只能定义非静态信息以及静态常量；可以正常继承和实现；不能被访问权限修饰符修饰可以被final、abstract来修饰；可以获取外部类所有方法；只能获取当前方法中的常量信息</p><p>成员内部类</p><p>在成员的位置定义；只能定义非静态信息以及静态常量；可以正常进行继承和实现；可以被访问权限修饰符修饰以及final/abstract来修饰；可以获取外部类所有信息</p><p>静态内部类</p><p>匿名内部类</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;final(最终)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关键字，修饰符     数据方法和类&lt;/p&gt;
&lt;p&gt;最终值：final修饰的数据&lt;/p&gt;
&lt;p&gt;1.如果是基本数据类型那么值不能改变，如果是引用数据类型那么地址值不能改变&lt;/p&gt;
&lt;p&gt;2.如果final修</summary>
      
    
    
    
    
    <category term="final 抽象 接口" scheme="http://senye.ink/tags/final-%E6%8A%BD%E8%B1%A1-%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>day11</title>
    <link href="http://senye.ink/2021/07/05/day11/"/>
    <id>http://senye.ink/2021/07/05/day11/</id>
    <published>2021-07-05T13:57:23.289Z</published>
    <updated>2021-07-05T13:58:36.880Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象的特征、特性</strong></p><p>封装</p><p>继承–重写（两等两小一大）super</p><p> 多态–编译时多态  运行时多态  向上造型–统一参数</p><p>静态变量</p><p>  static修饰的属性随着类的加载（静态常量池） 而加载到方法区的静态区里。静态变量称之为类变量，可以被类名的形式直接调用也可以被对象调用。存储在静态去的静态变量会被赋予系统默认初始值。无论创建多少和对象都共享同一个静态变量。使用静态变量的场景–希望属性被所有的对象共享。</p><p><strong>注意</strong>static不可以修饰局部变量</p><p>静态方法</p><p>随着类的加载而加载到方法区的静态区 称之为类方法可以被类名.的形式来调用也可以通过对象来调用。存储在静态区的静态方法不会被赋予系统默认初始值。如果静态方法被调用会被加载到栈中执行。</p><p><strong>注意</strong> </p><p>静态方法定义静态变量？不可以 方法只有被调用时才会执行 执行方法内容时才会加载方法中的内容 但是静态变量与类同级 前后不一致 所以所有的方法中都不能定义静态变量</p><p>静态信息可以直接访问静态信息不能直接访问非静态信息，非静态信息可以直接访问静态信息和非静态信息</p><p>Arrays.sort() System.arraycopy(); Arrays.copyOf;</p><p>静态方法可以重载？ 可以</p><p>可以重写？ 不可以 静态方法与类同级重写和对象一个级别所以静态方法没有重写形式 允许父子类中出现方法签名一致的两个静态方法 或者两个非静态方法</p><p><strong>静态代码块</strong></p><p>使用static修饰构造代码块</p><p>可以对静态属性进行初始化和预加载一些资源</p><p>静态代码随着类的加载只加载一次</p><p>static修饰的所有信息都只加载一次</p><p><strong>父子类的执行顺序</strong>—类级别 （父类静态信息-子类静态信息）—对象级别（父类（成员变量、构造代码块） –父类构造方法–子类（成员变量、构造代码块）–子类构造方法</p><hr><p>Stack Overflow 外网</p><p>经典应用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shape s1 = <span class="keyword">new</span> Rectangle(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(s1.getGirth());</span><br><span class="line">        Shape s2 = <span class="keyword">new</span> Circle(<span class="number">3</span>);</span><br><span class="line">        System.out.println(s2.getArea());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过构造方法来进行属性的初始化 赋值</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;<span class="comment">//图形类代表是任意的图形不能用矩形的计算公式来计算</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类有参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, y);<span class="comment">//调用父类的有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (getX() + getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">grtArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getY() * getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(x, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(r, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getGirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * <span class="number">3.14</span> * getX();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * getX() * getX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;面向对象的特征、特性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;封装&lt;/p&gt;
&lt;p&gt;继承–重写（两等两小一大）super&lt;/p&gt;
&lt;p&gt; 多态–编译时多态  运行时多态  向上造型–统一参数&lt;/p&gt;
&lt;p&gt;静态变量&lt;/p&gt;
&lt;p&gt;  static修饰的属性随着类的加载</summary>
      
    
    
    
    
    <category term="封装 静态代码块" scheme="http://senye.ink/tags/%E5%B0%81%E8%A3%85-%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>day10</title>
    <link href="http://senye.ink/2021/07/02/day10/"/>
    <id>http://senye.ink/2021/07/02/day10/</id>
    <published>2021-07-02T13:40:34.473Z</published>
    <updated>2021-07-02T13:43:57.919Z</updated>
    
    <content type="html"><![CDATA[<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>  多个类中出现了重复的内容，把这些重复的内容放到新的类中，通过extend关键字让原来的类和新的类产生了继承关系，原来的类称之为子类、新的类称之为父类。子类可以继承父类部分信息。</p><p>继承方式（树状图）</p><p>   单继承：一个类只能有一个父类，一个类可以有多个子类（支持多级继承）</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>  在父子类中出现了方法签名一致的方法称之为叫重写，遵守重写原则（两等两小一大）</p><p>  方法签名一致（如果方法签名一致java才会按照重写去检测是否遵守原则如果方法签名不一致则不检测重写原则—方法签名一致是重写的前提）</p><p>  如果父类的方法返回值类型是基本数据类型、void，那么子类的方法返回值类型和父类保持一致</p><p>  如果父类的方法返回值类型是引用数据类型，那么子类的方法返回值类型要么和父类一致，要么是父类方法返回值类型的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> A <span class="title">m</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">//A a=null;</span></span><br><span class="line">            &#125;</span><br><span class="line">    <span class="comment">//public int m()&#123;return 1;&#125;//int a=1;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> A/<span class="function">B <span class="title">m</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="keyword">null</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h4><p>（由定义信息的位置和操作信息的位置共同决定一个位置信息）子类  其他类 同包类 本类。（控制在哪些位置关系下操作定义的信息</p><table><thead><tr><th></th><th>本类</th><th>同包类</th><th align="right">子类</th><th>其他类</th></tr></thead><tbody><tr><td>public）（垃圾桶)</td><td>可以</td><td>可以</td><td align="right">可以</td><td></td></tr><tr><td>protected(水杯)</td><td>可以</td><td>可以</td><td align="right">可以</td><td>不可以</td></tr><tr><td>private</td><td>可以</td><td>不可以</td><td align="right">不可以</td><td>不可以</td></tr><tr><td>默认不写（窗户）</td><td>可以</td><td>可以</td><td align="right">同包子类</td><td>不可以</td></tr></tbody></table><p>子类的访问权限修饰符要么和父类一致要么大于父类权限的修饰符范围。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><ol><li><p>关键字，代表父类的对象可以调用父类的属性和方法</p></li><li><p>super语句可以在子类构造方法中调用父类的构造方法，要在首航使用</p></li><li><p>子类的每个构造方法中默认含有一个无参的super语句去调用父类的无参构造，如果父类没有提供无参构造，子类的每一个构造方法里需要手动书写有参super语句调用父类对应点有参构造</p></li><li><p>父类的对象优先于子类的对象产生</p></li><li><p>子类的<strong>对象信息</strong>的执行顺序 父类的构造代码块-父类构造的方法-子类构造的代码块-子类构造的方法</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>在程序操作过程中可以凸显多种形式</p><p>从java的时期来解释多态，编译时期和运行时期</p><p>编译时多态：在编译时期绑定代码 体现形式—重载 </p></li></ol><p>   运行时多态：在运行时期绑定代码  体现形式—重写 向上造型—前提是继承）</p><p>   向上造型</p><p>   声明类是父类，实际创建类是子类，这样创建的对象就是向上造型 向上造型的对象可以调用哪些方法看父类，方法的具体执行看子类是否有重写（父类—目录 子类—正文）</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.tedu.duotai;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DTDemo</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*//养宠物</span></span><br><span class="line"><span class="comment"> Pet p;</span></span><br><span class="line"><span class="comment"> //养条狗</span></span><br><span class="line"><span class="comment"> p=new Dog();*/</span></span><br><span class="line"> <span class="comment">//左边声明类是父类，右边实际创建对象的类是子类---向上造型</span></span><br><span class="line"> Pet p=<span class="keyword">new</span> Dog();</span><br><span class="line"> <span class="comment">//向上造型的对象可以调用哪些方法看父类</span></span><br><span class="line"> <span class="comment">//向上造型调用的方法的具体执行看子类是否有重写方法</span></span><br><span class="line"> p.eat();</span><br><span class="line"> <span class="comment">//调用方法</span></span><br><span class="line"> <span class="comment">//匿名对象适用于当作参数传递</span></span><br><span class="line"> m(<span class="keyword">new</span> Pet());</span><br><span class="line"> m(<span class="keyword">new</span> Dog());</span><br><span class="line"> m(<span class="keyword">new</span> Cat());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">(Pet p)</span></span>&#123;<span class="comment">//=new Pet(); =new Dog(); =new Cat();</span></span><br><span class="line"> p.eat();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义代表宠物的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在吃东西。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在睡觉。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义代表狗的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line"> <span class="comment">//重写</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在呼哧呼哧的吃。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bark</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在汪汪汪的叫。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义代表猫的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span></span>&#123;</span><br><span class="line"> <span class="comment">//重写</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在哼哧哼哧的吃。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> 磨爪子()&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;在磨爪子。。。&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>多态的优点：</p><p>1.参数功能统一</p><ol start="2"><li>高内聚低耦合 （解耦—降低耦合度）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h4&gt;&lt;p&gt;  多个类中出现了重复的内容，把这些重复的内容放到新的类中，通过extend关键字让原来的类和新的类产生了继承关系，原来的类称之为子类、新的</summary>
      
    
    
    
    
    <category term="继承 重写 super 多态" scheme="http://senye.ink/tags/%E7%BB%A7%E6%89%BF-%E9%87%8D%E5%86%99-super-%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>day09</title>
    <link href="http://senye.ink/2021/07/01/day09/"/>
    <id>http://senye.ink/2021/07/01/day09/</id>
    <published>2021-07-01T13:51:42.481Z</published>
    <updated>2021-07-01T13:52:50.840Z</updated>
    
    <content type="html"><![CDATA[<p>哥德巴赫猜想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeDe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//给定一个num</span></span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">if</span>((num&gt;<span class="number">6</span>)&amp;&amp;(num%<span class="number">2</span>==<span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;(num/<span class="number">2</span>);i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (isPrime(i)&amp;&amp;(isPrime(num-i)))&#123;</span><br><span class="line">                    System.out.println(num+<span class="string">&quot;=&quot;</span>+i+<span class="string">&quot;+&quot;</span>+(num-i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;请重新输入&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义方法---判断一个整数是否为质数</span></span><br><span class="line">    <span class="comment">//两个明确---方法返回值类型 boolean  参数列表 int m</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">        <span class="comment">//非正常情况---小于等于0</span></span><br><span class="line">        <span class="keyword">if</span>(m&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过for循环实现</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=(m/<span class="number">2</span>);i++)&#123;</span><br><span class="line">            <span class="comment">//判断是否被整除</span></span><br><span class="line">            <span class="keyword">if</span> (m%i==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//是质数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码：public static native void arraycopy(Object </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src：要复制的数组(源数组)</span><br><span class="line"></span><br><span class="line">srcPos：复制源数组的起始位置</span><br><span class="line"></span><br><span class="line">dest：目标数组</span><br><span class="line"></span><br><span class="line">destPos：目标数组的下标位置</span><br><span class="line"></span><br><span class="line">length：要复制的长度</span><br></pre></td></tr></table></figure><p>——————————————</p><p><strong>构造方法</strong></p><p> 构建对象</p><p>形式：1.没有方法返回值的类型；2.方法名于类同名 </p><p>如果类中没有定义构造方法会默认提供无参构造，如果类中定义构造方法就不会默认提供无参构造</p><p>一个类中至少含有一个构造方法</p><p> java中所有的非静态方法和属性只能通过对象调用</p><h4 id="This"><a href="#This" class="headerlink" title="This"></a>This</h4><h4 id="关键字，代表当前类的对象"><a href="#关键字，代表当前类的对象" class="headerlink" title="关键字，代表当前类的对象"></a>关键字，代表当前类的对象</h4><p>1.this可以代表还没有创建的对象可以代表刚创建的对象、可以代表一个正在使用的对象，this是一个虚拟的2.对象通过指定对象地址值来代表对象，代表的就是当前类正在活动的对象</p><p>3.this 语句，在构造方法中去调用别的构造方法，使用构造方法的首行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class ThisDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建Student对象</span><br><span class="line">        Student s1&#x3D;new Student();</span><br><span class="line">        &#x2F;&#x2F;this 代表刚创建的对象</span><br><span class="line">        System.out.println(&quot;s1:&quot;+s1);</span><br><span class="line">        &#x2F;&#x2F;创建一个Student的对象</span><br><span class="line">        Student s2&#x3D;new Student(&quot;tom&quot;);</span><br><span class="line">        &#x2F;&#x2F;this正在使用的对象</span><br><span class="line">        System.out.println(&quot;s2&quot;+s2);</span><br><span class="line">        &#x2F;&#x2F;this代表这个在活动的对象</span><br><span class="line">        s1.study();                    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;代表学生类</span><br><span class="line">class Student&#123;</span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    char gender;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;无参构造</span><br><span class="line">    public  Student()&#123;</span><br><span class="line">        System.out.println(&quot;this:&quot;+this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;有参构造</span><br><span class="line">    public Student(String name)&#123;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">        System.out.println(&quot;name:&quot;+this);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;行为</span><br><span class="line">    public void study()&#123;</span><br><span class="line">        System.out.println(this.name+&quot;在学习&quot;);</span><br><span class="line">        System.out.println(&quot;this:&quot;+this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>this:cn.tedu.text.Student@28d93b30<br>s1:cn.tedu.text.Student@28d93b30<br>name:cn.tedu.text.Student@1b6d3586<br>s2cn.tedu.text.Student@1b6d3586<br>null在学习<br>this:cn.tedu.text.Student@28d93b30</p><p>Process finished with exit code 0</p><h4 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h4><p>在类内方法外位置{}</p><p>构造代码块可以给属性进行初始化 优于构造方法优先执行</p><h4 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h4><p>在方法内（）</p><p>控制变量的生命周期，提高内存的利用率</p><h4 id="成员变量与局部变量的区别、"><a href="#成员变量与局部变量的区别、" class="headerlink" title="成员变量与局部变量的区别、"></a>成员变量与局部变量的区别、</h4><p><strong>定义位置：</strong>     成员变量：类内方法外          局部变量：方法内</p><p><strong>使用范围</strong>：    成员变量：整个类                  局部变量：整个方法</p><p><strong>生命周期：</strong>      成员变量：类创建对象的时候 随着对象的创建而产生 ，随着对象被回收而销毁      局部变量：随着当发被调用执行才产生，随着方法调用执行结束而销毁</p><h3 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h3><p>1、封装 继承 多态（抽象）、</p><p><strong>封装</strong></p><p>体现形式–方法，属性私有化通过提供的公共的访问方式来操作私有化属性的值 提高了数据的安全性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">public class FDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;创建Person类对象</span><br><span class="line">        Person p&#x3D;new Person();</span><br><span class="line">        &#x2F;&#x2F;操作对象属性</span><br><span class="line">        p.name&#x3D;&quot;lili&quot;;</span><br><span class="line">        &#x2F;&#x2F;p.age&#x3D;-10;</span><br><span class="line">        &#x2F;&#x2F;调用方法间接赋值</span><br><span class="line">        p.setAge(10);</span><br><span class="line">        p.gender&#x3D;&#39;女&#39;;</span><br><span class="line">        &#x2F;&#x2F;调用方法间接的获取类的私有化属性值</span><br><span class="line">        System.out.println(p.getAge()+&quot;,&quot;+p.gender+&quot;,&quot;+p.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;定义代表人的类</span><br><span class="line">class Person&#123;</span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    &#x2F;&#x2F;类中的所有属性都有安全性的问题，为了解决数据安全性的问题属性私有化</span><br><span class="line">    private String name;</span><br><span class="line">    &#x2F;&#x2F;private 私有化在属性和方法不能直接使用</span><br><span class="line">    private int age;</span><br><span class="line">    private char gender;</span><br><span class="line">    &#x2F;&#x2F;alt+insert  ---get 和  set</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(char gender) &#123;</span><br><span class="line">        this.gender &#x3D; gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public char getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;定义一个方法给私有化的属性进行赋值</span><br><span class="line">    public void setAge(int age)&#123;</span><br><span class="line">        if (age&lt;0) &#123;</span><br><span class="line">            System.out.println(&quot;信息有误&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age&#x3D;age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;定义方法获取私有化属性</span><br><span class="line">    public int getAge()&#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;有参构造</span><br><span class="line">   &#x2F;* public Person(int age)&#123;</span><br><span class="line">        if (age&lt;0) &#123;</span><br><span class="line">            System.out.println(&quot;信息有误&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            this.age&#x3D;age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    public void eat()&#123;</span><br><span class="line">        System.out.println(name+&quot;在吃饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;哥德巴赫猜想：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</summary>
      
    
    
    
    
    <category term="构造方法、成员变量、this" scheme="http://senye.ink/tags/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81this/"/>
    
  </entry>
  
</feed>
